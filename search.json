[
  {
    "objectID": "src/03_practicas/p2/301_composicion_condicional.html",
    "href": "src/03_practicas/p2/301_composicion_condicional.html",
    "title": "Práctica 2",
    "section": "",
    "text": "El artículo 14.2 del acuerdo de 22 de diciembre de 2010, del Consejo de Gobierno, por el que se aprueba el Reglamento de normas de evaluación y aprendizaje de la Universidad de Zaragoza establece:\nLa mención «Matrícula de Honor» podrá ser otorgada a estudiantes que hayan obtenido una calificación igual o superior a 9 en la asignatura. Su número no podrá exceder del 5 % de los estudiantes matriculados en dicha asignatura en el correspondiente grupo docente, salvo cuando sea inferior a 20, en cuyo caso se podrá conceder una sola matrícula de honor.\nEscribe un programa en Python que solicite al usuario el número de matriculados en un grupo docente de una asignatura y escriba el número máximo de matrículas de honor que pueden otorgarse en la Universidad de Zaragoza con ese número de matriculados.\nPor ejemplo:\nEscribe el número de matriculados en un grupo docente:\n58\nSe pueden otorgar como máximo 2 matrículas de honor.\nOtro ejemplo:\nEscribe el número de matriculados en un grupo docente:\n19\nSe pueden otorgar como máximo 1 matrículas de honor.\nEntrega: Escribe tu programa en un fichero denominado matriculas.py.\n\n\n\nEl artículo 14.1 del mencionado Reglamento establece a su vez que los resultados de cada una de las materias del plan de estudios se calificarán de 0 a 10 […], añadiendo una calificación cualitativa según la siguiente escala: de 0 a 5, suspenso; de 5 a 7, aprobado; de 7 a 9, notable y de 9 a 10, sobresaliente.\nEscribe un programa en Python que solicite al usuario el valor de una calificación numérica de un estudiante y escriba en la pantalla la calificación cualitativa correspondiente.\nEjemplos de ejecución:\nEscribe la nota numérica:\n8\nCalificación: Notable.\nEscribe la nota numérica:\n4.99\nCalificación: Suspenso.\nTen en cuenta la posibilidad de que el usuario introduzca calificaciones no válidas fuera del intervalo \\([0, 10]\\):\nEscribe la nota numérica:\n12.5\nNota numérica no válida.\nEscribe la nota numérica:\n-3\nNota numérica no válida.\nEntrega: Escribe tu programa en un fichero denominado notas.py."
  },
  {
    "objectID": "src/03_practicas/p2/301_composicion_condicional.html#calificaciones",
    "href": "src/03_practicas/p2/301_composicion_condicional.html#calificaciones",
    "title": "Práctica 2",
    "section": "",
    "text": "El artículo 14.2 del acuerdo de 22 de diciembre de 2010, del Consejo de Gobierno, por el que se aprueba el Reglamento de normas de evaluación y aprendizaje de la Universidad de Zaragoza establece:\nLa mención «Matrícula de Honor» podrá ser otorgada a estudiantes que hayan obtenido una calificación igual o superior a 9 en la asignatura. Su número no podrá exceder del 5 % de los estudiantes matriculados en dicha asignatura en el correspondiente grupo docente, salvo cuando sea inferior a 20, en cuyo caso se podrá conceder una sola matrícula de honor.\nEscribe un programa en Python que solicite al usuario el número de matriculados en un grupo docente de una asignatura y escriba el número máximo de matrículas de honor que pueden otorgarse en la Universidad de Zaragoza con ese número de matriculados.\nPor ejemplo:\nEscribe el número de matriculados en un grupo docente:\n58\nSe pueden otorgar como máximo 2 matrículas de honor.\nOtro ejemplo:\nEscribe el número de matriculados en un grupo docente:\n19\nSe pueden otorgar como máximo 1 matrículas de honor.\nEntrega: Escribe tu programa en un fichero denominado matriculas.py.\n\n\n\nEl artículo 14.1 del mencionado Reglamento establece a su vez que los resultados de cada una de las materias del plan de estudios se calificarán de 0 a 10 […], añadiendo una calificación cualitativa según la siguiente escala: de 0 a 5, suspenso; de 5 a 7, aprobado; de 7 a 9, notable y de 9 a 10, sobresaliente.\nEscribe un programa en Python que solicite al usuario el valor de una calificación numérica de un estudiante y escriba en la pantalla la calificación cualitativa correspondiente.\nEjemplos de ejecución:\nEscribe la nota numérica:\n8\nCalificación: Notable.\nEscribe la nota numérica:\n4.99\nCalificación: Suspenso.\nTen en cuenta la posibilidad de que el usuario introduzca calificaciones no válidas fuera del intervalo \\([0, 10]\\):\nEscribe la nota numérica:\n12.5\nNota numérica no válida.\nEscribe la nota numérica:\n-3\nNota numérica no válida.\nEntrega: Escribe tu programa en un fichero denominado notas.py."
  },
  {
    "objectID": "src/03_practicas/p2/301_composicion_condicional.html#malabares-con-instrucciones-condicionales",
    "href": "src/03_practicas/p2/301_composicion_condicional.html#malabares-con-instrucciones-condicionales",
    "title": "Práctica 2",
    "section": "2 Malabares con instrucciones condicionales",
    "text": "2 Malabares con instrucciones condicionales\nEscribe un programa en Python que solicite un valor entero al usuario y realice las siguientes acciones:\n\nSi el valor dado por el usuario es par, lo dividirá entre 2. Después:\n\nSi el resultado de esta división es impar, elevará el resultado al cuadrado.\nPor el contrario, si el resultado de la división es par, lo volverá a dividir entre 2.\n\nEn el caso de que el valor dado por el usuario sea impar, entonces:\n\nSi el valor dado es positivo, lo multiplicará por 5.\nSi es negativo, le cambiará el signo.\n\n\nFinalmente, el programa informará al usuario del valor transformado, escribiendo por pantalla el resultado.\nEjemplos de ejecución:\nIntroduzca un número entero:\n5\nResultado: 25\nIntroduzca un número entero:\n-2\nResultado: 1\nIntroduzca un número entero:\n-45\nResultado: 45\nIntroduzca un número entero:\n-68\nResultado: -17\nIntroduzca un número entero:\n10\nResultado: 25\nIntroduzca un número entero:\n0\nResultado: 0\nEntrega: Escribe tu programa en un fichero denominado malabares.py."
  },
  {
    "objectID": "src/03_practicas/p2/301_composicion_condicional.html#triángulos",
    "href": "src/03_practicas/p2/301_composicion_condicional.html#triángulos",
    "title": "Práctica 2",
    "section": "3 Triángulos",
    "text": "3 Triángulos\nEscribe un programa en Python que solicite al usuario las longitudes de los tres lados de un triángulo y que escriba en la pantalla si dicho triángulo es equilátero, isósceles o escaleno.\nEl programa debe presentar una forma de interacción con el usuario como la que se muestra en los ejemplos siguientes, que corresponden con ejecuciones independientes del programa:\nEscriba las longitudes de los lados de un triángulo:\n4.1\n4.1\n4.1\nEl triángulo es equilátero.\nEscriba las longitudes de los lados de un triángulo:\n2\n2\n3\nEl triángulo es isósceles.\nEscriba las longitudes de los lados de un triángulo:\n3.5\n6\n6\nEl triángulo es isósceles.\nEscriba las longitudes de los lados de un triángulo:\n3\n6\n3\nEl triángulo es isósceles.\nEscriba las longitudes de los lados de un triángulo:\n3\n4\n5\nEl triángulo es escaleno.\nEscriba las longitudes de los lados de un triángulo:\n6\n0\n5\nAlgún dato no es estrictamente positivo.\nEscriba las longitudes de los lados de un triángulo:\n-2\n3\n5\nAlgún dato no es estrictamente positivo.\nResuelve el problema de forma incremental, es decir, construyendo distintas versiones del programa que, poco a poco, vayan incorporando los requisitos solicitados en el enunciado. En particular, se sugiere seguir el siguiente proceso:\n\nComienza escribiendo un programa que pida los tres datos al usuario y, si los tres son iguales, escriba en la pantalla el mensaje «El triángulo es equilátero».\nContinúa modificando el programa para que, además de ser capaz de determinar si el triángulo es equilátero, determine también uno de los casos en los que es isósceles (por ejemplo, cuando los dos primeros lados son iguales).\nContinúa haciendo que el programa detecte los otros dos casos en los que el triángulo es isósceles (cuando los dos últimos lados son los iguales y cuando son iguales el primero y el tercero).\nComplétalo haciendo que escriba que es escaleno cuando no sea equilátero ni isósceles.\nPor último, añade el código necesario para que el programa compruebe si los tres datos suministrados por el usuario son positivos y haz que, en caso de que no lo sean, escriba el mensaje de error «Algún dato no es positivo».\n\nEntrega: Escribe tu programa en un fichero denominado triangulos.py."
  },
  {
    "objectID": "src/03_practicas/p2/301_composicion_condicional.html#cajero-automático",
    "href": "src/03_practicas/p2/301_composicion_condicional.html#cajero-automático",
    "title": "Práctica 2",
    "section": "4 Cajero automático",
    "text": "4 Cajero automático\nEscribe un programa en Python que tenga el siguiente comportamiento:\nCantidad a retirar en euros:\n280\n\nBilletes 50 €: 5\nBilletes 20 €: 1\nBilletes 10 €: 1\nEl programa informa al usuario del número de billetes que le devolverá el cajero automático de un banco al retirar la cantidad de dinero especificada. El cajero dispone únicamente de billetes de diez, de veinte y de cincuenta euros y siempre va a minimizar el número de billetes a entregar.\nCantidad a retirar en euros:\n590\n\nBilletes 50 €: 11\nBilletes 20 €: 2\nBilletes 10 €: 0\nLas cantidades que se pueden retirar del cajero tienen que ser estrictamente positivas, múltiplos de 10 e iguales o inferiores al límite máximo de disposición en cajero de 600 €. Este aspecto debe ser comprobado por el programa:\nCantidad a retirar en euros:\n-10\nError: la cantidad a retirar no puede ser negativa.\nCantidad a retirar en euros:\n800\nError: la cantidad a retirar excede el límite máximo.\nCantidad a retirar en euros:\n225\nError: la cantidad a retirar tiene que ser un múltiplo de 10.\nEntrega: Escribe tu programa en un fichero denominado cajero.py."
  },
  {
    "objectID": "src/03_practicas/p2/301_composicion_condicional.html#entrega-de-la-práctica",
    "href": "src/03_practicas/p2/301_composicion_condicional.html#entrega-de-la-práctica",
    "title": "Práctica 2",
    "section": "5 Entrega de la práctica",
    "text": "5 Entrega de la práctica\nAntes del sábado 1 de marzo a las 18:00, deberán haberse subido a Moodle los siguientes ficheros:\n\nmatriculas.py\nnotas.py\nmalabares.py\ntriangulos.py\ncajero.py"
  },
  {
    "objectID": "src/03_practicas/p0/101_introductoria.html#objetivos",
    "href": "src/03_practicas/p0/101_introductoria.html#objetivos",
    "title": "Práctica 0",
    "section": "Objetivos",
    "text": "Objetivos\n\nInstalar el entorno de trabajo\nFamiliarizarse con el entorno de trabajo\n\nEditor de texto\nTerminal\n\nAprender a ejecutar (no escribir) código Python\nIntuyendo Python\nEntregar"
  },
  {
    "objectID": "src/03_practicas/p0/101_introductoria.html#instalación-del-entorno-de-trabajo",
    "href": "src/03_practicas/p0/101_introductoria.html#instalación-del-entorno-de-trabajo",
    "title": "Práctica 0",
    "section": "Instalación del entorno de trabajo",
    "text": "Instalación del entorno de trabajo\nPara desarrollar en python necesitamos:\n\nIntérprete de Python: Python\nEntorno de desarrollo: Visual Studio Code"
  },
  {
    "objectID": "src/03_practicas/p0/101_introductoria.html#familiarizarse-con-el-entorno-de-trabajo",
    "href": "src/03_practicas/p0/101_introductoria.html#familiarizarse-con-el-entorno-de-trabajo",
    "title": "Práctica 0",
    "section": "Familiarizarse con el entorno de trabajo",
    "text": "Familiarizarse con el entorno de trabajo\nDurante el proceso de desarrollo, siempre tendremos en cuenta:\n\nSistema ficheros: Localización de los programas\nCódigo fuente: Contenido de los programas\nTerminal: Ejecución de programas python\n\nEstos tres elementos pueden ser controlados desde Visual Studio Code."
  },
  {
    "objectID": "src/03_practicas/p0/101_introductoria.html#programa-interactivo",
    "href": "src/03_practicas/p0/101_introductoria.html#programa-interactivo",
    "title": "Práctica 0",
    "section": "Programa interactivo",
    "text": "Programa interactivo\n\nMás adelante en el curso aprenderás a hacer programas que requieran de la interacción del usuario.\nDicha interacción se realiza también en la propia terminal.\nPara familiarizarte ahora con este comportamiento, vamos a escribir y ejecutar un programa interactivo."
  },
  {
    "objectID": "src/03_practicas/p0/101_introductoria.html#intuyendo-python",
    "href": "src/03_practicas/p0/101_introductoria.html#intuyendo-python",
    "title": "Práctica 0",
    "section": "Intuyendo Python",
    "text": "Intuyendo Python\nA continuación evaluaremos nuestra capacidad de intuir y entender el funcionamiento de código python.\nTarea: Documenta los siguientes programas en un docstring.\n\nDescarga o copia los ficheros en la carpeta p0.\nÁbrelos con el editor de texto y lee su contenido.\nEjecuta los programas desde la terminal de VSCode.\nAñade un docstring al principio de cada fichero incluyendo tu nombre y explicando qué hace el programa.\n\nNota: Puedes hacer Clic derecho &gt; Guardar enlace como... en los nombres de cada fichero para descargarlos o hacer clic en el icono del portapapeles para copiar todo el contenido."
  },
  {
    "objectID": "src/03_practicas/p0/101_introductoria.html#entrega-de-la-práctica",
    "href": "src/03_practicas/p0/101_introductoria.html#entrega-de-la-práctica",
    "title": "Práctica 0",
    "section": "Entrega de la práctica",
    "text": "Entrega de la práctica\nTodas las prácticas se entregarán a través de Moodle. Esta Práctica 0 no es evaluable, pero sí se deberá entregar para familiarizarse con el proceso.\nTarea: Entrega el código de la práctica.\n\nVerifica que has nombrado correctamente los ficheros. Un fichero mal nombrado no será evaluado.\nVerifica que has añadido un docstring a cada fichero con tu nombre y NIP.\nVerifica que el funcionamiento de los programas es correcto.\nAccede a la entrega en Moodle y lee si hay instrucciones extra.\nSube los ficheros *.py individualmente (sin comprimir y sin crear carpetas adicionales).\n\nNota: No se aceptarán entregas fuera de plazo. En el caso de que se acerque la fecha límite de entrega, se recomienda al menos subir los ejercicios que se hayan terminado. Se podrán resubir tantas veces como se desee antes de la fecha límite de entrega."
  },
  {
    "objectID": "src/02_problemas/303-composicion_iterativa_for.html",
    "href": "src/02_problemas/303-composicion_iterativa_for.html",
    "title": "Problemas 5",
    "section": "",
    "text": "Escribe un programa en Python que solicite al usuario una secuencia de números enteros positivos (terminada en 0) y que calcule la media de los números introducidos. Si el número introducido es negativo, el programa debe ignorarlo y seguir solicitando números.\nIntroduce un número entero:\n2\nIntroduce un número entero:\n-4\nIntroduce un número entero:\n4\nIntroduce un número entero:\n-1\nIntroduce un número entero:\n0\nLa media de los números es: 3.0\n\n\nSolución\n\nsuma = 0\ncontador = 0\n\nnumero = 1\nwhile numero != 0:\n    print(\"Introduce un número entero:\")\n    numero = int(input())\n\n    if numero &gt; 0:\n        suma += numero\n        contador += 1\n\nmedia = suma / contador\nprint(f\"La media de los números es: {media}\")"
  },
  {
    "objectID": "src/02_problemas/303-composicion_iterativa_for.html#media-de-una-secuencia-de-enteros",
    "href": "src/02_problemas/303-composicion_iterativa_for.html#media-de-una-secuencia-de-enteros",
    "title": "Problemas 5",
    "section": "",
    "text": "Escribe un programa en Python que solicite al usuario una secuencia de números enteros positivos (terminada en 0) y que calcule la media de los números introducidos. Si el número introducido es negativo, el programa debe ignorarlo y seguir solicitando números.\nIntroduce un número entero:\n2\nIntroduce un número entero:\n-4\nIntroduce un número entero:\n4\nIntroduce un número entero:\n-1\nIntroduce un número entero:\n0\nLa media de los números es: 3.0\n\n\nSolución\n\nsuma = 0\ncontador = 0\n\nnumero = 1\nwhile numero != 0:\n    print(\"Introduce un número entero:\")\n    numero = int(input())\n\n    if numero &gt; 0:\n        suma += numero\n        contador += 1\n\nmedia = suma / contador\nprint(f\"La media de los números es: {media}\")"
  },
  {
    "objectID": "src/02_problemas/303-composicion_iterativa_for.html#potencia-enésima",
    "href": "src/02_problemas/303-composicion_iterativa_for.html#potencia-enésima",
    "title": "Problemas 5",
    "section": "2 Potencia enésima",
    "text": "2 Potencia enésima\nEscribe un programa en Python que solicite al usuario dos números enteros positivos base y exponente y que calcule la potencia enésima de base elevado a exponente. El programa debe comprobar que base sea mayor estricto que cero y exponente sea mayor o igual que cero. No se permite el uso del operador **.\nIntroduce la base:\n2\nIntroduce el exponente:\n3\n2^3 = 8\nIntroduce la base:\n0\nIntroduce la base (mayor que 0):\n2\nIntroduce el exponente:\n-2\nIntroduce el exponente (mayor o igual que 0):\n3\n2^3 = 8\n\n\nSolución\n\nprint(\"Introduce la base:\")\nbase = int(input())\nwhile base &lt;= 0:\n    print(\"Introduce la base (mayor que 0):\")\n    base = int(input())\n\nprint(\"Introduce el exponente:\")\nexponente = int(input())\nwhile exponente &lt; 0:\n    print(\"Introduce el exponente (mayor o igual que 0):\")\n    exponente = int(input())\n\nresultado = 1\nfor i in range(0, exponente):\n    resultado *= base\n\nprint(f\"{base}^{exponente} = {resultado}\")"
  },
  {
    "objectID": "src/02_problemas/303-composicion_iterativa_for.html#caja-de-nxm",
    "href": "src/02_problemas/303-composicion_iterativa_for.html#caja-de-nxm",
    "title": "Problemas 5",
    "section": "3 Caja de NxM",
    "text": "3 Caja de NxM\nEscribe un programa en Python que solicite al usuario dos números enteros positivos n y m y que dibuje una caja de n filas y m columnas. Las líneas horizontales se representarán con el caracter - (menos), las verticales con el caracter | (barra vertical) y las esquinas con el caracter + (más).\nIntroduce el número de filas:\n3\nIntroduce el número de columnas:\n3\n+---+\n|   |\n|   |\n|   |\n+---+\n\nIntroduce el número de filas:\n3\nIntroduce el número de columnas:\n7\n+-------+\n|       |\n|       |\n|       |\n+-------+\n\n\n\nSolución\n\nprint(\"Introduce el número de filas:\")\nn = int(input())\n\nprint(\"Introduce el número de columnas:\")\nm = int(input())\n\nprint(\"+\", end=\"\")\nfor i in range(0, m):\n    print(\"-\", end=\"\")\nprint(\"+\")\n\nfor i in range(0, n):\n    print(\"|\", end=\"\")\n    for j in range(0, m):\n        print(\" \", end=\"\")\n    print(\"|\")\n\nprint(\"+\", end=\"\")\nfor i in range(0, m):\n    print(\"-\", end=\"\")\nprint(\"+\")"
  },
  {
    "objectID": "src/02_problemas/303-composicion_iterativa_for.html#triángulo-de-caracteres",
    "href": "src/02_problemas/303-composicion_iterativa_for.html#triángulo-de-caracteres",
    "title": "Problemas 5",
    "section": "4 Triángulo de caracteres",
    "text": "4 Triángulo de caracteres\nEscribe un programa en Python que solicite al usuario un carácter y un número entero positivo n y que dibuje un triángulo de n filas con el carácter introducido.\nIntroduce un carácter:\nx\nIntroduce un número entero:\n3\nx\nxx\nxxx\nIntroduce un carácter:\no\nIntroduce un número entero:\n5\no\noo\nooo\noooo\nooooo\n\n\nSolución\n\nprint(\"Introduce un carácter:\")\ncaracter = input()\nprint(\"Introduce un número entero:\")\nn = int(input())\n\nfor i in range(1, n+1):\n    for j in range(0, i):\n        print(caracter, end=\"\")\n    print()"
  },
  {
    "objectID": "src/02_problemas/301-composicion_condicional.html",
    "href": "src/02_problemas/301-composicion_condicional.html",
    "title": "Problemas 3",
    "section": "",
    "text": "Escribe un programa en Python que solicite al usuario una respuesta y determine si está seguro de eliminar un archivo. El programa debe aceptar las respuestas s, n, si y no.\n¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\nsi\nARCHIVO ELIMINADO\n¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\nn\nSKIP\n\n\nSolución\n\nprint(\"¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\")\nrespuesta = input()\n\nif respuesta == \"s\" or respuesta == \"si\":\n    print(\"ARCHIVO ELIMINADO\")\nelif respuesta == \"n\" or respuesta == \"no\":\n    print(\"SKIP\")"
  },
  {
    "objectID": "src/02_problemas/301-composicion_condicional.html#está-seguro-de-que-desea-eliminar-el-archivo",
    "href": "src/02_problemas/301-composicion_condicional.html#está-seguro-de-que-desea-eliminar-el-archivo",
    "title": "Problemas 3",
    "section": "",
    "text": "Escribe un programa en Python que solicite al usuario una respuesta y determine si está seguro de eliminar un archivo. El programa debe aceptar las respuestas s, n, si y no.\n¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\nsi\nARCHIVO ELIMINADO\n¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\nn\nSKIP\n\n\nSolución\n\nprint(\"¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\")\nrespuesta = input()\n\nif respuesta == \"s\" or respuesta == \"si\":\n    print(\"ARCHIVO ELIMINADO\")\nelif respuesta == \"n\" or respuesta == \"no\":\n    print(\"SKIP\")"
  },
  {
    "objectID": "src/02_problemas/301-composicion_condicional.html#determina-si-es-una-casilla-de-oca",
    "href": "src/02_problemas/301-composicion_condicional.html#determina-si-es-una-casilla-de-oca",
    "title": "Problemas 3",
    "section": "2 Determina si es una casilla de Oca",
    "text": "2 Determina si es una casilla de Oca\nEscribe un programa en Python que solicite al usuario un número de casilla y determine si es una casilla de Oca.\nUna casilla es Oca si es múltiplo de 9 o (múltiplo de 9) + 5.\n\n5, 9, 14, 18, 23, 27, 32, 36, 41, 45, 50, 54, 59\n\nIntroduce el número de casilla:\n9\n¿Es casilla de Oca?\nTrue\nIntroduce el número de casilla:\n6\n¿Es casilla de Oca?\nFalse\n\n\nSolución\n\nprint(\"Introduce el número de casilla:\")\n\ncasilla = int(input())\n\nes_oca = casilla % 9 == 0 or casilla % 9 == 5\n\nprint(\"¿Es casilla de Oca?\")\nprint(es_oca)"
  },
  {
    "objectID": "src/02_problemas/301-composicion_condicional.html#determina-si-es-un-año-bisiesto",
    "href": "src/02_problemas/301-composicion_condicional.html#determina-si-es-un-año-bisiesto",
    "title": "Problemas 3",
    "section": "3 Determina si es un año bisiesto",
    "text": "3 Determina si es un año bisiesto\nEscribe un programa en Python que solicite al usuario un año y determine si es bisiesto.\nUn año es bisiesto si\n\nes divisible por 4 y no es divisibles por 100\no es divisible por 400.\n\nIntroduce el año:\n2020\n¿Es año bisiesto?\nTrue\n\n\nSolución\n\nprint(\"Introduce el año:\")\nanyo = int(input())\n\nes_bisiesto = (anyo % 4 == 0 and anyo % 100 != 0) or anyo % 400 == 0\n\nprint(\"¿Es año bisiesto?\")\nprint(es_bisiesto)\n\n\n\nSolución más legible\n\nprint(\"Introduce el año:\")\naño = int(input())\n\nmultiplo_4 = anyo % 4 == 0\nmultiplo_100 = anyo % 100 == 0\nmultiplo_400 = anyo % 400 == 0\nes_bisiesto = multiplo_400 or (multiplo_4 and not multiplo_100)\n\nprint(\"¿Es año bisiesto?\")\nprint(es_bisiesto)"
  },
  {
    "objectID": "src/02_problemas/301-composicion_condicional.html#saludar-según-la-hora",
    "href": "src/02_problemas/301-composicion_condicional.html#saludar-según-la-hora",
    "title": "Problemas 3",
    "section": "4 Saludar según la hora",
    "text": "4 Saludar según la hora\nEscribe un programa en Python que solicite al usuario un número entero que represente la hora y salude según la hora introducida. Saludo según el rango de horas:\n\nDe 07:00 a 11:59 : Buenos días\nDe 12:00 a 19:59 : Buenas tardes\nDe 20:00 a 06:59 : Buenas noches\n\nIntroduce la hora:\n8\nBuenos días\nIntroduce la hora:\n14\nBuenas tardes\n\n\nSolución\n\nprint(\"Introduce la hora:\")\nhora = int(input())\n\nif 7 &lt;= hora &lt; 12:\n    print(\"Buenos días\")\nelif 12 &lt;= hora &lt; 20:\n    print(\"Buenas tardes\")\nelif 20 &lt;= hora &lt;= 24 or 0 &lt;= hora &lt; 7:\n    print(\"Buenas noches\")\n\n\n\nSolución más sencilla\n\nprint(\"Introduce la hora:\")\nhora = int(input())\n\nif 7 &lt;= hora &lt; 12:\n    print(\"Buenos días\")\nelif 12 &lt;= hora &lt; 20:\n    print(\"Buenas tardes\")\nelse:\n    print(\"Buenas noches\")"
  },
  {
    "objectID": "src/02_problemas/301-composicion_condicional.html#números-ordenados",
    "href": "src/02_problemas/301-composicion_condicional.html#números-ordenados",
    "title": "Problemas 3",
    "section": "5 Números ordenados",
    "text": "5 Números ordenados\nEscribe un programa en Python que solicite al usuario tres números y determine si están ordenados de menor a mayor, de mayor a menor o desordenados.\nIntroduce tres números:\n1\n2\n3\nEstán ordenados de menor a mayor\nIntroduce tres números:\n3\n2\n1\nEstán ordenados de mayor a menor\nIntroduce tres números:\n2\n3\n1\nNo están ordenados\n\n\nSolución\n\nprint(\"Introduce tres números:\")\na = int(input())\nb = int(input())\nc = int(input())\n\nif a &lt;= b &lt;= c:\n    print(\"Están ordenados de menor a mayor\")\nelif a &gt;= b &gt;= c:\n    print(\"Están ordenados de mayor a menor\")\nelse:\n    print(\"No están ordenados\")"
  },
  {
    "objectID": "src/02_problemas/100-fundamentos.html",
    "href": "src/02_problemas/100-fundamentos.html",
    "title": "Problemas 1",
    "section": "",
    "text": "¿Qué valor tienen las variables a y b al final del siguiente código?\na = 5\nb = a\na = 10\n\n\nSolución\n\n\n\n\nVariable\nValor final\n\n\n\n\na\n10\n\n\nb\n5"
  },
  {
    "objectID": "src/02_problemas/100-fundamentos.html#asignaciones-secuenciales",
    "href": "src/02_problemas/100-fundamentos.html#asignaciones-secuenciales",
    "title": "Problemas 1",
    "section": "",
    "text": "¿Qué valor tienen las variables a y b al final del siguiente código?\na = 5\nb = a\na = 10\n\n\nSolución\n\n\n\n\nVariable\nValor final\n\n\n\n\na\n10\n\n\nb\n5"
  },
  {
    "objectID": "src/02_problemas/100-fundamentos.html#cambio-de-valores",
    "href": "src/02_problemas/100-fundamentos.html#cambio-de-valores",
    "title": "Problemas 1",
    "section": "2 Cambio de valores",
    "text": "2 Cambio de valores\nConsigue que el valor de a pase a ser el de b y el de b pase a ser el de a.\na = 5\nb = 10\n\n# ??\n\nprint(a)  # 10\nprint(b)  # 5\n\n\nSolución\n\na = 5\nb = 10\n\ntemp = a\na = b\nb = temp\n\nprint(a)  # 10\nprint(b)  # 5"
  },
  {
    "objectID": "src/02_problemas/100-fundamentos.html#averigua-el-tipo-de-dato",
    "href": "src/02_problemas/100-fundamentos.html#averigua-el-tipo-de-dato",
    "title": "Problemas 1",
    "section": "3 Averigua el tipo de dato",
    "text": "3 Averigua el tipo de dato\n¿Cuál es el tipo de dato de cada una de las siguientes variables?\na = 5\nb = 5.0\nc = \"5\"\nd = a + b\ne = a * 2\nf = b / 2\ng = a + int(c)\nh = str(a) + c\n\n\nSolución\n\n\n\n\nVariable\nTipo de dato\n\n\n\n\na\nint\n\n\nb\nfloat\n\n\nc\nstr\n\n\nd\nfloat\n\n\ne\nint\n\n\nf\nfloat\n\n\ng\nint\n\n\nh\nstr"
  },
  {
    "objectID": "src/01_teoria/06_ficheros/601_ficheros.reveal.html#chapter",
    "href": "src/01_teoria/06_ficheros/601_ficheros.reveal.html#chapter",
    "title": "Teoría 601",
    "section": "Chapter",
    "text": "Chapter"
  },
  {
    "objectID": "src/01_teoria/05_estructuras_de_datos/503_objetos.reveal.html#chapter",
    "href": "src/01_teoria/05_estructuras_de_datos/503_objetos.reveal.html#chapter",
    "title": "Teoría 503",
    "section": "Chapter",
    "text": "Chapter"
  },
  {
    "objectID": "src/01_teoria/05_estructuras_de_datos/501_listas.reveal.html#chapter",
    "href": "src/01_teoria/05_estructuras_de_datos/501_listas.reveal.html#chapter",
    "title": "Teoría 501",
    "section": "Chapter",
    "text": "Chapter"
  },
  {
    "objectID": "src/01_teoria/04_modularizacion_de_codigo/402_funciones_return.reveal.html#chapter",
    "href": "src/01_teoria/04_modularizacion_de_codigo/402_funciones_return.reveal.html#chapter",
    "title": "Teoría 402",
    "section": "Chapter",
    "text": "Chapter"
  },
  {
    "objectID": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.reveal.html#generación-de-números-pseudo-aleatorios",
    "href": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.reveal.html#generación-de-números-pseudo-aleatorios",
    "title": "Teoría 306",
    "section": "Generación de números pseudo-aleatorios",
    "text": "Generación de números pseudo-aleatorios"
  },
  {
    "objectID": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.reveal.html#cálculo-numérico",
    "href": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.reveal.html#cálculo-numérico",
    "title": "Teoría 306",
    "section": "Cálculo numérico",
    "text": "Cálculo numérico"
  },
  {
    "objectID": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.html",
    "href": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.html",
    "title": "Teoría 306",
    "section": "",
    "text": "Como se dijo en la primera sesión: los ordenadores son deterministas.\n\nLos programas que escribimos siempre producen el mismo resultado para una misma entrada.\n\nEso tiene sus ventajas:\n\nNos permite predecir el comportamiento de los programas.\nNos permite reproducir errores.\n\nSin embargo, a veces necesitamos aleatoriedad.\n\nJuegos, simulaciones, etc.\n\n\n\n\n\n\n\nLa forma de obtener “aleatoriedad” en un ordenador determinista es mediante los algortimos de generación de números pseudo-aleatorios.\nEstos algoritmos generan una secuencia de números que estadísticamente se comportan como si fueran aleatorios.\n\nEl algoritmo genera un nuevo número a partir del anterior: \\(x_n = f(x_{n-1})\\).\nNecesita un valor \\(x_0\\) para empezar.\n\nEste valor \\(x_0\\) inicial se denomina semilla.\n\nSi utilizamos la misma semilla, obtendremos la misma secuencia.\nDeberemos, entonces, dar con la forma de obtener esa primera semilla de forma segura.\n\n\n\n\n\n\n\nElegir la semilla para un programa pseudo-aleatorio puede ser un labor crítica de seguridad.\n\nSi se compromete la secuencia de números, se compromete la seguridad del sistema.\n\nExisten diversas fuentes que podemos usar para obtener una semilla (de menos segura, a más segura):\n\nPedir al usuario que introduzca un número.\nLeer la hora del sistema.\nLeer la temperatura del procesador.\nLeer la posición del ratón.\nLeer la entrada del usuario.\nUtilizar Hardware especializado.\n\n\n\n\n\n\nLavarand es un muro de lámparas de lava construido por Cloudflare para generar números aleatorios.\n\nLas lámparas de lava se iluminan y se apagan de forma aleatoria.\nSe captura el estado de las lámparas y se convierte en un número aleatorio.\nSe actualiza cada 60 segundos.\n\n\n\n\n\n\nLavarand, the Wall of Entropy @ Cloudflare\n\n\n\n\n\n\n\n\n\nExisten algoritmos sencillos que podemos usar para generar números pseudo-aleatorios.\n\nSi bien es cierto que no son seguros, pueden ser útiles para fines didácticos.\n\nA modo de ejemplo, vamos a ver cómo funciona el algoritmo de congruencia lineal.\n\n\\(x_{n+1} = (a \\cdot x_n + c) \\mod m\\)\n\\(m&gt;0\\), \\(0 \\leq a &lt; m\\), \\(0 \\leq c &lt; m\\), \\(0 \\leq x_0 &lt; m\\)\n\n\n\n\nseed = 42\na = 22695477\nc = 1\nm = 2 ** 32\n\nfor i in range(0, 5):\n    seed = (a * seed + c) % m\n    print(seed)\n\n953210035\n3724055312\n1961185873\n1409857734\n3384186111\n\n\n\n\n\n\n\nEn lugar de implementar vuestra propia función de generación de números pseudo-aleatorios, podéis y deberéis utilizar librerías sofisticadas y seguras.\nEn Python, la librería random proporciona funciones para generar números pseudo-aleatorios.\n\nrandom.seed() establece la semilla.\nrandom.randint(a, b) genera un número entero aleatorio entre a y b.\nrandom.random() genera un número real aleatorio entre 0 y 1.\n\n\n\n\nimport random\n\nrandom.seed(42)\n\nfor i in range(0, 5):\n    print(random.randint(0, 2**32))\n\n2746317213\n1181241943\n958682846\n3163119785\n1812140441\n\n\n\n\n\nEscribe un programa en Python que simule un chequeo de habilidad: - El programa debe lanzar un dado de D20 (20 caras). - Si el resultado es mayor o igual que el umbral de habilidad (que el usuario introduce), el chequeo es exitoso.\nimport random\n\nrandom.seed(42)  # Semilla fija para reproducibilidad\n\nprint(\"Introduce el umbral de habilidad:\")\numbral = int(input())\n\nresultado = random.randint(1, 20)\nprint(f\"Resultado: {resultado}\")\nif resultado &gt;= umbral:\n    print(\"Pass!\")\nelse:\n    print(\"Fail!\")"
  },
  {
    "objectID": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.html#generación-de-números-pseudo-aleatorios",
    "href": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.html#generación-de-números-pseudo-aleatorios",
    "title": "Teoría 306",
    "section": "",
    "text": "Como se dijo en la primera sesión: los ordenadores son deterministas.\n\nLos programas que escribimos siempre producen el mismo resultado para una misma entrada.\n\nEso tiene sus ventajas:\n\nNos permite predecir el comportamiento de los programas.\nNos permite reproducir errores.\n\nSin embargo, a veces necesitamos aleatoriedad.\n\nJuegos, simulaciones, etc.\n\n\n\n\n\n\n\nLa forma de obtener “aleatoriedad” en un ordenador determinista es mediante los algortimos de generación de números pseudo-aleatorios.\nEstos algoritmos generan una secuencia de números que estadísticamente se comportan como si fueran aleatorios.\n\nEl algoritmo genera un nuevo número a partir del anterior: \\(x_n = f(x_{n-1})\\).\nNecesita un valor \\(x_0\\) para empezar.\n\nEste valor \\(x_0\\) inicial se denomina semilla.\n\nSi utilizamos la misma semilla, obtendremos la misma secuencia.\nDeberemos, entonces, dar con la forma de obtener esa primera semilla de forma segura.\n\n\n\n\n\n\n\nElegir la semilla para un programa pseudo-aleatorio puede ser un labor crítica de seguridad.\n\nSi se compromete la secuencia de números, se compromete la seguridad del sistema.\n\nExisten diversas fuentes que podemos usar para obtener una semilla (de menos segura, a más segura):\n\nPedir al usuario que introduzca un número.\nLeer la hora del sistema.\nLeer la temperatura del procesador.\nLeer la posición del ratón.\nLeer la entrada del usuario.\nUtilizar Hardware especializado.\n\n\n\n\n\n\nLavarand es un muro de lámparas de lava construido por Cloudflare para generar números aleatorios.\n\nLas lámparas de lava se iluminan y se apagan de forma aleatoria.\nSe captura el estado de las lámparas y se convierte en un número aleatorio.\nSe actualiza cada 60 segundos.\n\n\n\n\n\n\nLavarand, the Wall of Entropy @ Cloudflare\n\n\n\n\n\n\n\n\n\nExisten algoritmos sencillos que podemos usar para generar números pseudo-aleatorios.\n\nSi bien es cierto que no son seguros, pueden ser útiles para fines didácticos.\n\nA modo de ejemplo, vamos a ver cómo funciona el algoritmo de congruencia lineal.\n\n\\(x_{n+1} = (a \\cdot x_n + c) \\mod m\\)\n\\(m&gt;0\\), \\(0 \\leq a &lt; m\\), \\(0 \\leq c &lt; m\\), \\(0 \\leq x_0 &lt; m\\)\n\n\n\n\nseed = 42\na = 22695477\nc = 1\nm = 2 ** 32\n\nfor i in range(0, 5):\n    seed = (a * seed + c) % m\n    print(seed)\n\n953210035\n3724055312\n1961185873\n1409857734\n3384186111\n\n\n\n\n\n\n\nEn lugar de implementar vuestra propia función de generación de números pseudo-aleatorios, podéis y deberéis utilizar librerías sofisticadas y seguras.\nEn Python, la librería random proporciona funciones para generar números pseudo-aleatorios.\n\nrandom.seed() establece la semilla.\nrandom.randint(a, b) genera un número entero aleatorio entre a y b.\nrandom.random() genera un número real aleatorio entre 0 y 1.\n\n\n\n\nimport random\n\nrandom.seed(42)\n\nfor i in range(0, 5):\n    print(random.randint(0, 2**32))\n\n2746317213\n1181241943\n958682846\n3163119785\n1812140441\n\n\n\n\n\nEscribe un programa en Python que simule un chequeo de habilidad: - El programa debe lanzar un dado de D20 (20 caras). - Si el resultado es mayor o igual que el umbral de habilidad (que el usuario introduce), el chequeo es exitoso.\nimport random\n\nrandom.seed(42)  # Semilla fija para reproducibilidad\n\nprint(\"Introduce el umbral de habilidad:\")\numbral = int(input())\n\nresultado = random.randint(1, 20)\nprint(f\"Resultado: {resultado}\")\nif resultado &gt;= umbral:\n    print(\"Pass!\")\nelse:\n    print(\"Fail!\")"
  },
  {
    "objectID": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.html#cálculo-numérico",
    "href": "src/01_teoria/03_composicion/306_composicion_iterativa_avanzada.html#cálculo-numérico",
    "title": "Teoría 306",
    "section": "2 Cálculo numérico",
    "text": "2 Cálculo numérico\n\n\n2.1 Cálculo numérico\n\nUno de los primeros usos de la computación fue el cálculo numérico.\n\nEl cálculo numérico consiste en aproximar soluciones a problemas matemáticos.\n\nLos bucles y los números pseudo-aleatorios son dos herramientas muy útiles para realizar cálculos numéricos.\n\n\n\n2.1.1 Ejercicio: Aproximación de una integral por el método del punto medio\nEscribe un programa Python que calcule la integral de la función \\(f(x) = x^3\\) en el intervalo [0, 1] mediante la regla del punto medio.\nAnalíticamente:\n\\[\n\\int_{0}^{1} x^3 \\, dx = \\left.\\frac{x^4}{4}\\right|_0^1 = \\frac{1^4}{4} - \\frac{0^4}{4} = \\frac{1}{4}\n\\]\nNuméricamente\n\n\n\nPodemos aproximar numéricamente la integral:\n\nDividiendo el intervalo en subintervalos pequeños.\nCalculando el área de cada subintervalo.\n\n\n\n\n\n\n\nSolución:\ninicio = 0\nfin = 1\nintervalos = 1000\npaso = (fin - inicio) / intervalos\n\nintegral = 0  # acumulador\n\nx = inicio\nwhile x &lt; fin:\n    y = x ** 3  # f(x) = x^3\n    area = paso * y\n    integral += area\n    x += paso\n\nprint(integral)\n\n\n\n\n\n\n¿Por qué no podemos usar range(a, b, step)?\n\nLa función range solo acepta números enteros.\n¿Se te ocurre alguna forma de solucionarlo?\n\n\n\n\n\n\n\n2.1.2 Ejercicio: Aproximación de coseno por serie de Maclaurin\nEscribe un programa Python que calcule una aproximación del coseno de un número real x mediante la serie de Maclaurin:\n\\[\n\\cos(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n}{(2n)!}x^{2n} = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\frac{x^6}{6!} + \\cdots\n\\]\nEl programa debe solicitar el ángulo en radianes x y el número de términos n a sumar.\n\nSolución:\nimport math\n\nprint(\"Introduce el ángulo (en radianes):\")\nx = float(input())\nprint(\"Introduce el número de términos:\")\nn = int(input())\n\ncos_approx = 0\nfor i in range(0, n):\n    cos_approx += ((-1) ** i) * ((x ** (2 * i)) / math.factorial(2 * i))\n\nprint(cos_approx)\n\n\n\n2.1.3 Ejercicio: Aproximación de pi por método de Monte Carlo\nEscribe un programa Python que calcule una aproximación de \\(\\pi\\) mediante el método de Monte Carlo (simulación y conteo).\n\nSabemos que:\n\nPara un círculo de radio 1: \\(area_{círculo} = \\pi\\).\nPara un cuadrado de lado 2: \\(area_{cuadrado} = 4\\).\n\\(\\frac{area_{círculo}}{area_{cuadrado}} = \\frac{\\pi}{4}\\).\n\\(\\pi = 4 \\times \\frac{area_{círculo}}{area_{cuadrado}}\\).\n\n\n\n\nSimulamos que lanzamos dardos aleatoriamente en el cuadrado\n\nGeneramos puntos (x, y) aleatorios en el cuadrado.\nContamos cuantos caen dentro del círculo: \\(x^2 + y^2 \\leq 1\\).\nLa probabilidad de que un dardo caiga dentro del círculo es \\(\\frac{\\pi}{4}\\).\n\nUn\n\n\\(\\pi \\approx 4 \\times \\frac{dardos_{dentro}}{dardos_{total}}\\).\n\n\n\n\nSolución:\nimport random\n\nnum_dardos = 1000\n\ndardos_dentro = 0\nfor i in range(0, num_dardos):\n    x = random.uniform(-1, 1)\n    y = random.uniform(-1, 1)\n    if x ** 2 + y ** 2 &lt;= 1:\n        dardos_dentro += 1\n\npi_approx = 4 * dardos_dentro / num_dardos\nprint(pi_approx)"
  },
  {
    "objectID": "src/01_teoria/03_composicion/304_composicion_iterativa_for.reveal.html#tipos-de-bucles",
    "href": "src/01_teoria/03_composicion/304_composicion_iterativa_for.reveal.html#tipos-de-bucles",
    "title": "Teoría 304",
    "section": "Tipos de bucles",
    "text": "Tipos de bucles"
  },
  {
    "objectID": "src/01_teoria/03_composicion/304_composicion_iterativa_for.reveal.html#el-bucle-for",
    "href": "src/01_teoria/03_composicion/304_composicion_iterativa_for.reveal.html#el-bucle-for",
    "title": "Teoría 304",
    "section": "El bucle for",
    "text": "El bucle for"
  },
  {
    "objectID": "src/01_teoria/03_composicion/304_composicion_iterativa_for.reveal.html#usos-avanzados-de-for",
    "href": "src/01_teoria/03_composicion/304_composicion_iterativa_for.reveal.html#usos-avanzados-de-for",
    "title": "Teoría 304",
    "section": "Usos avanzados de for",
    "text": "Usos avanzados de for"
  },
  {
    "objectID": "src/01_teoria/03_composicion/304_composicion_iterativa_for.html",
    "href": "src/01_teoria/03_composicion/304_composicion_iterativa_for.html",
    "title": "Teoría 304",
    "section": "",
    "text": "En la sesión anterior, vimos que los bucles tienen usos muy diversos:\n\nValidar datos, acumular cálculos, repetir mensajes por pantalla, etc.\n\nA efectos prácticos, todos cumplen una de estas estructuras:\n\nRepetir una acción hasta obtener un resultado deseado.\nRepetir una acción un número determinado de veces.\n\nLa diferencia entre ambos radica en si previamente conocemos o no el número de iteraciones.\n\n\n\n\nSumar números del 1 al 5:\nsuma = 0\ni = 1\nwhile i &lt;= 5:\n    suma += i\n    i += 1\nprint(f\"Iteraciones: {i}, Suma: {suma}\")\n\nSabemos que son 5 iteraciones.\n\n\nSumar hasta que suma &gt; 100:\nsuma = 0\ni = 1\nwhile suma &lt;= 100:\n    suma += i\n    i += 1\nprint(f\"Iteraciones: {i}, Suma: {suma}\")\n\nNo sabemos cuántas iteraciones serán.\n\n\n\n\n\n\n\nEl bucle while permite cubrir ambos casos, y es la opción más flexible.\nSin embargo, cuando el número de iteraciones es conocido de antemano, siempre repetimos el mismo patrón.\n\n\n\nCuando no necesitamos valores de i:\ni = 0\n\nwhile i &lt; NUM_ITERACIONES:\n    # Código que no usa la i\n    i += 1\n\nCuando vamos a usar la i:\ni = VALOR_INICIAL\n\nwhile i &lt;= VALOR_FINAL:\n    # Código que depende de la i\n    i += 1\n\n\n\nElementos:\n\nUna variable iteradora: i\nUna condición de finalización del bucle: i &lt; NUM_ITERACIONES\nUn incremento de la variable iteradora: i += 1\n\n\n\n\nEste patrón es tán común que la mayoría de lenguajes de programación tienen una estructura específica para facilitar usarlo:\n\nLa sintaxis: for\n\nSu funcionamiento específico varía según el lenguaje.\nEn el caso de Python, técnicamente no implementa el patrón for sino for-each.\n\nAÚN NO VAMOS A ABORDAR ESA DIFERENCIA.\nDe momento, utilizaremos el for-each como si fuera un for."
  },
  {
    "objectID": "src/01_teoria/03_composicion/304_composicion_iterativa_for.html#tipos-de-bucles",
    "href": "src/01_teoria/03_composicion/304_composicion_iterativa_for.html#tipos-de-bucles",
    "title": "Teoría 304",
    "section": "",
    "text": "En la sesión anterior, vimos que los bucles tienen usos muy diversos:\n\nValidar datos, acumular cálculos, repetir mensajes por pantalla, etc.\n\nA efectos prácticos, todos cumplen una de estas estructuras:\n\nRepetir una acción hasta obtener un resultado deseado.\nRepetir una acción un número determinado de veces.\n\nLa diferencia entre ambos radica en si previamente conocemos o no el número de iteraciones.\n\n\n\n\nSumar números del 1 al 5:\nsuma = 0\ni = 1\nwhile i &lt;= 5:\n    suma += i\n    i += 1\nprint(f\"Iteraciones: {i}, Suma: {suma}\")\n\nSabemos que son 5 iteraciones.\n\n\nSumar hasta que suma &gt; 100:\nsuma = 0\ni = 1\nwhile suma &lt;= 100:\n    suma += i\n    i += 1\nprint(f\"Iteraciones: {i}, Suma: {suma}\")\n\nNo sabemos cuántas iteraciones serán.\n\n\n\n\n\n\n\nEl bucle while permite cubrir ambos casos, y es la opción más flexible.\nSin embargo, cuando el número de iteraciones es conocido de antemano, siempre repetimos el mismo patrón.\n\n\n\nCuando no necesitamos valores de i:\ni = 0\n\nwhile i &lt; NUM_ITERACIONES:\n    # Código que no usa la i\n    i += 1\n\nCuando vamos a usar la i:\ni = VALOR_INICIAL\n\nwhile i &lt;= VALOR_FINAL:\n    # Código que depende de la i\n    i += 1\n\n\n\nElementos:\n\nUna variable iteradora: i\nUna condición de finalización del bucle: i &lt; NUM_ITERACIONES\nUn incremento de la variable iteradora: i += 1\n\n\n\n\nEste patrón es tán común que la mayoría de lenguajes de programación tienen una estructura específica para facilitar usarlo:\n\nLa sintaxis: for\n\nSu funcionamiento específico varía según el lenguaje.\nEn el caso de Python, técnicamente no implementa el patrón for sino for-each.\n\nAÚN NO VAMOS A ABORDAR ESA DIFERENCIA.\nDe momento, utilizaremos el for-each como si fuera un for."
  },
  {
    "objectID": "src/01_teoria/03_composicion/304_composicion_iterativa_for.html#el-bucle-for",
    "href": "src/01_teoria/03_composicion/304_composicion_iterativa_for.html#el-bucle-for",
    "title": "Teoría 304",
    "section": "2 El bucle for",
    "text": "2 El bucle for\n\n\n2.1 Composición Iterativa: for\n\n\n\nLa estructura for es una forma simplificada de implementar un bucle while que itere un número determinado de veces.\nSe encarga automáticamente de:\n\nInicializar la variable iteradora con el primer valor.\nIncrementar la variable iteradora al final de la iteración.\nEvaluar la condición i &lt; VALOR_FINAL\n\nEl segundo valor que pasamos a range NO se incluye en las iteraciones.\n\n# bloque_de_instrucciones_principal_1\nfor i in range(VALOR_INICIAL, VALOR_FINAL):\n    # bloque_de_instrucciones\n# bloque_de_instrucciones_principal_2\n\n\n\n\n\n\n\n2.2 Uso de range()\n\nEs muy importante tener en cuenta el funcionamiento de range() para no cometer errores off by one.\n\nrange(N, M) genera números en el rango [N, M).\n\n\n\n\nfor i in range(0, 5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\nEl 5 NO se incluye en las iteraciones.\n\n\n\n2.2.1 Ejemplo: Repetición de un mensaje 100 veces (for)\nfor i in range(0, 100):\n    print(\"I will lock my computer when I leave my desk\")\n\nLos valores de i irán de 0 a 99.\nEso da un total de 100 iteraciones.\n\n\n\n\n\n\n\nTrata de evitar manías como inicializar i a 1 si no es necesario. (range(1, N+1))\nfor i in range(1, 100+1):\n    print(\"I will lock my computer when I leave my desk\")\n\n\n\n\n\n\n\n\n\nEs posible que tu editor avise de que la variable i no se usa en el código. Puedes llamarla _ (barra baja) para indicar que no se va a usar, pero siempre tiene que haber una variable después de la palabra clave for.\n\n\n\n\n\n\n2.2.2 Ejemplo: Sumar números del 1 al 5 (for)\nsuma = 0\n\nfor i in range(1, 5+1):\n    suma += i\n\nprint(f\"Suma: {suma}\")\n\nAquí sí necesitamos usar valores específicos de i.\n\nUsamos 5+1 porque resulta más explícito que 6.\n\n\n\n\n\n\n2.3 Cuando usar for y cuando while\n\n¿Conozco previamente el número de iteraciones (o rango de valores) que necesito?\n\nSi: for\nNo: while\n\nPistas (son sugerencias, no reglas):\n\nSi te encuentras creando una variable i y la condición tiene la forma i &lt; N:\n\nSeguramente puedas usar for.\n\nSi te preguntas cómo puedes evaluar una condición distinta de i &lt; N:\n\nProbablemente necesites usar while.\n\nSi te preguntas cómo puedes interrumpir un bucle for a mitad:\n\nCasi seguro que necesitas usar while.\n\n\n\n\n\n2.3.1 Ejercicio: Cuándo usar for y while\n\n¿Qué tipo de bucle usarías para cada uno de los siguientes casos?\n\n\n\nPedir un dato a un usuario hasta que introduzca un valor correcto.\n\nwhile\n\n\n\nCalcular el factorial de un número.\n\nfor\n\n\n\nPedir un número al usuario y mostrar los números pares hasta ese número.\n\nfor\n\n\n\nSolicitar un número PIN con un máximo de 3 intentos.\n\nwhile\n\n\n\nInvertir las cifras de un número.\n\nwhile\n\n\n\nSolicitar 5 números al usuario y mostrar la media.\n\nfor\n\n\n\nSolicitar una secuencia de números al usuario y mostrar la media.\n\nwhile\n\n\n\nSolicitar un numero N, solicitar luego N números al usuario y mostrar la media.\n\nfor\n\n\n\n\n\n\n2.3.2 Ejemplo: Sumar números hasta n\nEste programa solicita un número n al usuario y suma todos los números hasta n.\n\n\nprint(\"Introduce un número:\")\nn = int(input())\n\nsuma = 0\nfor i in range(1, n+1):  # El 0 no lo necesito\n    suma += i\n\nprint(f\"La suma hasta {n} es {suma}\")\n\nIntroduce un número:\n5\nLa suma hasta 5 es 15\n\n\n\n\n\n2.3.3 Ejemplo: Factorial (for)\nEste programa solicita un número n al usuario y calcula el factorial de n.\n\n\nprint(\"Introduce un número:\")\nn = int(input())\n\nfactorial = 1\nfor i in range(1, n+1):\n    factorial *= i\n\nprint(f\"{n}! = {factorial}\")\n\nIntroduce un número:\n5\n5! = 120\n\n\n\n\n\n2.3.4 Ejemplo: Media de 3 números\nEste programa solicita 3 números al usuario y calcula la media.\n\n\nsuma = 0\nfor i in range(1, 3+1):\n    print(f\"Introduce el número {i}:\")\n    suma += int(input())\n\nmedia = suma / 3\nprint(f\"La media de los números es {media}\")\n\nIntroduce el número 1:\n2\nIntroduce el número 2:\n4\nIntroduce el número 3:\n6\nLa media de los números es 4.0\n\n\n\n\n\n2.3.5 Ejemplo: Media de N números\nEste programa solicita una cantidad de números n al usuario y, después, esos n números y calcula la media.\n\n\nprint(\"Introduce una cantidad:\")\nn = int(input())\n\nsuma = 0\nfor i in range(1, n+1):\n    print(f\"Introduce el número {i}:\")\n    suma += int(input())\n\nmedia = suma / n\nprint(f\"La media de los números es {media}\")\n\nIntroduce una cantidad:\n3\nIntroduce el número 1:\n2\nIntroduce el número 2:\n4\nIntroduce el número 3:\n6\nLa media de los números es 4.0"
  },
  {
    "objectID": "src/01_teoria/03_composicion/304_composicion_iterativa_for.html#usos-avanzados-de-for",
    "href": "src/01_teoria/03_composicion/304_composicion_iterativa_for.html#usos-avanzados-de-for",
    "title": "Teoría 304",
    "section": "3 Usos avanzados de for",
    "text": "3 Usos avanzados de for\n\n\n3.1 Usos avanzados de range()\n\nLa función range() es la encargada de determinar el rango de valores que se van a iterar.\nRealmente existen tres formas de usar range():\n\nrange(N): Genera valores desde 0 hasta N-1.\nrange(N, M): Genera valores desde N hasta M-1.\nrange(N, M, S): Genera valores desde N hasta M-1 incrementando i+=S.\n\nEs decir:\n\nrange(5) = range(0, 5) = range(0, 5, 1).\n\n\n\n\n\n\n\n\nAunque resulte tentador escribir menos, es recomendable ser explícito y evitar range(N) en favor de range(0, N).\n\n\n\n\n\n3.1.1 Ejemplo: Pinta los números pares del 0 al 10\n\n\nUsando range(0, 11)\nfor i in range(0, 11):\n    if i % 2 == 0:\n        print(i)\n0\n2\n4\n6\n8\n10\n\nUsando range(0, 11, 2)\nfor i in range(0, 11, 2):\n    print(i)\n \n0\n2\n4\n6\n8\n10"
  },
  {
    "objectID": "src/01_teoria/03_composicion/302_composicion_iterativa_while.reveal.html#límites-de-la-composición-secuencial-y-condicional",
    "href": "src/01_teoria/03_composicion/302_composicion_iterativa_while.reveal.html#límites-de-la-composición-secuencial-y-condicional",
    "title": "Teoría 302",
    "section": "Límites de la composición secuencial y condicional",
    "text": "Límites de la composición secuencial y condicional"
  },
  {
    "objectID": "src/01_teoria/03_composicion/302_composicion_iterativa_while.reveal.html#composición-iterativa",
    "href": "src/01_teoria/03_composicion/302_composicion_iterativa_while.reveal.html#composición-iterativa",
    "title": "Teoría 302",
    "section": "Composición Iterativa",
    "text": "Composición Iterativa"
  },
  {
    "objectID": "src/01_teoria/03_composicion/302_composicion_iterativa_while.reveal.html#usos-avanzados-de-while",
    "href": "src/01_teoria/03_composicion/302_composicion_iterativa_while.reveal.html#usos-avanzados-de-while",
    "title": "Teoría 302",
    "section": "Usos avanzados de while",
    "text": "Usos avanzados de while"
  },
  {
    "objectID": "src/01_teoria/03_composicion/302_composicion_iterativa_while.html",
    "href": "src/01_teoria/03_composicion/302_composicion_iterativa_while.html",
    "title": "Teoría 302",
    "section": "",
    "text": "En la sesión anterior vimos cómo componer programas de modo que algunas instrucciones sólo se ejecuten si se cumple una condición\n\nComposición secuencial y condicional\n\n\n\n\n\n\n\n\nNo todos los programas pueden ser escritos de manera secuencial y condicional\n\n\n\n\n\n\nEscribe programa Python que imprima por pantalla la siguiente frase 100 veces:\n\nI will lock my computer when I leave my desk\n\n\n\n\n\n\n\n\n¿Es implementable con composición secuencial y condicional?\n\n\n\n\n\nSí, se puede resolver con composición secuencial\n\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\n# 90 veces más\n\nInconveniente: Repetitivo\n\n\n\n\n\nEscribe programa Python que solicite un número entero al usuario y que imprima por pantalla la siguiente frase tantas veces como el número introducido:\n\nI will lock my computer when I leave my desk\n\nprint(\"Introduce un número entero:\")\nn = int(input())\n\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\n# ...\n\nInconveniente: Cuando paro?\n\nprint(\"Introduce un número entero:\")\nn = int(input())\n\nif n &gt; 1:\n    print(\"I will lock my computer when I leave my desk\")\nif n &gt; 2:\n    print(\"I will lock my computer when I leave my desk\")\n# ...\n\nInconveniente: Y si n es muy grande?\n\n\n\n\n\nEscribe programa Python que imprima por pantalla todos los múltiplos de 3 menores que 100.\nif 1 % 3 == 0:\n    print(1)\n\nif 2 % 3 == 0:\n    print(2)\n\nif 3 % 3 == 0:\n    print(3)\n# ...\n\nMismos problemas que antes\n\n\n\n\n\n\n\nTodos estos programas tienen cumplen al menos una de estas dos condiciones:\n\nRequieren un número determinado de pasos demasiado grande\nRequieren un número indeterminado de pasos"
  },
  {
    "objectID": "src/01_teoria/03_composicion/302_composicion_iterativa_while.html#límites-de-la-composición-secuencial-y-condicional",
    "href": "src/01_teoria/03_composicion/302_composicion_iterativa_while.html#límites-de-la-composición-secuencial-y-condicional",
    "title": "Teoría 302",
    "section": "",
    "text": "En la sesión anterior vimos cómo componer programas de modo que algunas instrucciones sólo se ejecuten si se cumple una condición\n\nComposición secuencial y condicional\n\n\n\n\n\n\n\n\nNo todos los programas pueden ser escritos de manera secuencial y condicional\n\n\n\n\n\n\nEscribe programa Python que imprima por pantalla la siguiente frase 100 veces:\n\nI will lock my computer when I leave my desk\n\n\n\n\n\n\n\n\n¿Es implementable con composición secuencial y condicional?\n\n\n\n\n\nSí, se puede resolver con composición secuencial\n\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\n# 90 veces más\n\nInconveniente: Repetitivo\n\n\n\n\n\nEscribe programa Python que solicite un número entero al usuario y que imprima por pantalla la siguiente frase tantas veces como el número introducido:\n\nI will lock my computer when I leave my desk\n\nprint(\"Introduce un número entero:\")\nn = int(input())\n\nprint(\"I will lock my computer when I leave my desk\")\nprint(\"I will lock my computer when I leave my desk\")\n# ...\n\nInconveniente: Cuando paro?\n\nprint(\"Introduce un número entero:\")\nn = int(input())\n\nif n &gt; 1:\n    print(\"I will lock my computer when I leave my desk\")\nif n &gt; 2:\n    print(\"I will lock my computer when I leave my desk\")\n# ...\n\nInconveniente: Y si n es muy grande?\n\n\n\n\n\nEscribe programa Python que imprima por pantalla todos los múltiplos de 3 menores que 100.\nif 1 % 3 == 0:\n    print(1)\n\nif 2 % 3 == 0:\n    print(2)\n\nif 3 % 3 == 0:\n    print(3)\n# ...\n\nMismos problemas que antes\n\n\n\n\n\n\n\nTodos estos programas tienen cumplen al menos una de estas dos condiciones:\n\nRequieren un número determinado de pasos demasiado grande\nRequieren un número indeterminado de pasos"
  },
  {
    "objectID": "src/01_teoria/03_composicion/302_composicion_iterativa_while.html#composición-iterativa",
    "href": "src/01_teoria/03_composicion/302_composicion_iterativa_while.html#composición-iterativa",
    "title": "Teoría 302",
    "section": "2 Composición Iterativa",
    "text": "2 Composición Iterativa\n\n\n2.1 Composición Iterativa: concepto\n\nLa composición iterativa es una estructura de control que permite repetir un bloque de instrucciones.\nExisten varias formas de composición iterativa\n\nwhile, for\n\n\n\n\n\n2.2 Composición Iterativa: while\n\n\n\nLa estructura while permite repetir la ejecución de un bloque de instrucciones mientras se cumpla una condición.\n\nEvalúa una expresión lógica (valor booleano)\nSi el valor es True: ejecuta el bloque.\n\nAl terminal el bloque, vuelve arriba para evaluar la condición de nuevo.\n\nSi el valor es False: no ejecuta el bloque.\n\nEl bloque de instrucciones que se ejecuta iterativamente se identifica por su indentación.\n\n# bloque_de_instrucciones_principal_1\n\nwhile condicion:\n    # bloque_de_instrucciones que\n    # se ejecuta si condicion es True\n\n# bloque_de_instrucciones_principal_2\n\n\n\n\n\n\n2.2.1 Ejemplo: Repetición de un mensaje 100 veces (fallido)\n\nPara resolver el problema de la repetición de un mensaje 100 veces, utilizaremos un bucle while que repita la instrucción print() 100 veces.\n\nNecesitaremos una forma de contar las veces que se ha repetido el mensaje.\nNecesitaremos una condición que nos permita salir del bucle.\n\n\n¿Funcionará?\ncount = 0\nwhile count &lt; 100:\n    print(\"I will lock my computer when I leave my desk\")\nI will lock my computer when I leave my desk\nI will lock my computer when I leave my desk\nI will lock my computer when I leave my desk\n… hasta el infinito\n\n\n¿Qué problema tiene este programa?\n\nBucle infinito: count nunca se incrementa\n\n¿Cómo solucionarlo?\n\nIncrementar el valor de count en cada iteración\n\n\n\n\n\n\n2.3 Incremento de una variable\n\nUn concepto fundamental de los bucles es modificar el estado de la condición.\n\nSi dentro del bloque de una iteración ninguna de las variables usadas en la condición cambia, estaremos ante un bucle infinito.\n\nLa forma más común de modificación en los bucles es incrementar o decrementar una variable.\nEstas variables que comienzan con un valor específico y se incrementan o decrementan en cada iteración las llamaremos acumuladores.\n\n\n\ncount = 0\nwhile count &lt; 3:\n    print(\"Hello\")\n    count = count + 1\nprint(\"Bye\")\n\nHello\nHello\nHello\nBye\n\n\n\n\n2.3.1 Ejemplo: Repetición de un mensaje 100 veces (correcto)\n\nSabiendo esto, podemos corregir el programa anterior:\n\nIncrementar el valor de count en cada iteración\n\n\ncount = 0\nwhile count &lt; 100:\n    print(\"I will lock my computer when I leave my desk\")\n    count = count + 1\nI will lock my computer when I leave my desk\nI will lock my computer when I leave my desk\nI will lock my computer when I leave my desk\n… 97 veces más\n\n\n\n\n2.4 Incremento de una variable: asignación aumentada\n\nEn la sección anterior, vimos por primera vez el uso de una variable en su propia asignación.\n\ncount = count + 1\n\nEsta es una operación muy común en los bucles.\nEn Python, existe la asignación aumentada.\n\ncount += 1: Equivale a count = count + 1\ncount -= 1: Equivale a count = count - 1\n\nOtros atajos: *= (producto), /= (división), %= (resto), **= (potencia)\n\n\n\n2.4.1 Ejemplo: Repetición de un mensaje 100 veces (alternativa con asignación aumentada)\n\nSabiendo esto, podemos corregir el programa anterior:\n\nIncrementar el valor de count en cada iteración\n\n\ncount = 0\nwhile count &lt; 100:\n    print(\"I will lock my computer when I leave my desk\")\n    count += 1\nI will lock my computer when I leave my desk\nI will lock my computer when I leave my desk\nI will lock my computer when I leave my desk\n… 97 veces más\n\n\n\n2.4.2 Ejemplo: Contar hasta 5\n\nEn el ejemplo anterior, todas las iteraciones ejecutaban las instrucciones con exactamente los mismos valores\n\npor lo que el resultado de cada iteración era idéntico.\n\nSin embargo, entre una iteración y otra los valores de las variables no siempre serán los mismos.\n\n\n\ncount = 1\nwhile count &lt;= 5:\n    print(count)\n    count += 1\n\n1\n2\n3\n4\n5\n\n\n\n\n\n2.4.3 Ejemplo: Repetición de un mensaje N veces\nprint(\"Introduce un número entero:\")\nn = int(input())\n\ncount = 0\nwhile count &lt; n:\n    print(\"I will lock my computer when I leave my desk\")\n    count += 1\n\nHemos decidido (recomendable, será necesario más adelante):\n\niniciar la variable count = 0 y terminar el bucle cuando count &lt; n.\n\nSería equivalente:\n\niniciar la variable count = 1 y terminar el bucle cuando count &lt;= n.\n\n\n\n\n\n2.4.4 Ejemplo: Calculo de múltiplos de 3\nEste programa imprime por pantalla todos los múltiplos de 3 menores que 100.\n\n\nnum = 1\n\nwhile num &lt; 100:\n    if num % 3 == 0:\n        print(num)\n    num += 1\n\n3\n6\n9\n… hasta 99\n\n\n\n\n\n2.4.5 Ejemplo: Sumatorio\n\nLos acumuladores tienen muchos usos más allá de contar las iteraciones de un bucle\n\nPor ejemplo, podemos utilizar para calcular sumatorios\n\n\n\\[\n\\sum_{i=1}^{100} 2i^2\n\\]\nsumatorio = 0\ni = 1\nwhile i &lt;= 100:\n    sumatorio += 2 * (i ** 2)\n    i += 1\n\n\n\n\n2.5 Bucles anidados\n\nAl igual que con las estructuras condicionales, podemos anidar bucles.\n\n\n\nx = 0\nwhile x &lt; 3:\n    y = 0\n    while y &lt; 3:\n        print(f\"x={x}, y={y}\")\n        y += 1\n    x += 1\n\nx=0, y=0\nx=0, y=1\nx=0, y=2\nx=1, y=0\nx=1, y=1\nx=1, y=2\nx=2, y=0\nx=2, y=1\nx=2, y=2\n\n\n\n\n2.5.1 Ejemplo: Tabla de multiplicar\nEscribe un programa en Python que imprima por pantalla la tabla de multiplicar del 1 al 10.\nx = 1\n\nwhile x &lt;= 10:\n    y = 1\n    while y &lt;= 10:\n        print(f\"{x} x {y} = {x * y}\")\n        y += 1\n    x += 1\n\nFíjate en cómo en este caso iniciamos las como x = 1 e y = 1 y terminamos los bucles cuando x &lt;= 10 e y &lt;= 10.\n\nEsto es porque nos interesa que tengan estos valores.\nPiensa qué implicaciones tendría iniciar x = 0 y terminar el bucle cuando x &lt; 10"
  },
  {
    "objectID": "src/01_teoria/03_composicion/302_composicion_iterativa_while.html#usos-avanzados-de-while",
    "href": "src/01_teoria/03_composicion/302_composicion_iterativa_while.html#usos-avanzados-de-while",
    "title": "Teoría 302",
    "section": "3 Usos avanzados de while",
    "text": "3 Usos avanzados de while\n\n\n3.1 Interacción con el usuario\n\nRecuerda que la interacción con el usuario se realiza también mediante instrucciones.\nEstas instrucciones pueden estar dentro de un bloque condicional.\n\n\n\nprint(\"Introduce un número par:\")\nn = int(input())\nwhile n % 2 != 0:\n    print(\"Introduce un número par:\")\n    n = int(input())\nn = 1\nwhile n % 2 != 0:\n    print(\"Introduce un número par:\")\n    n = int(input())\npar = False\nwhile not par:\n    print(\"Introduce un número par:\")\n    n = int(input())\n    if n % 2 == 0:\n        par = True\n\nIntroduce un número par:\n3\nIntroduce un número par:\n5\nIntroduce un número par:\n4"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.reveal.html#cadenas-de-texto",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.reveal.html#cadenas-de-texto",
    "title": "Teoría 202",
    "section": "Cadenas de texto",
    "text": "Cadenas de texto"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.reveal.html#booleanos",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.reveal.html#booleanos",
    "title": "Teoría 202",
    "section": "Booleanos",
    "text": "Booleanos"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.html",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.html",
    "title": "Teoría 202",
    "section": "",
    "text": "Palabra reservada: str\nLiterales: \"hola\", 'hola', \"\", '', f\"hola {nombre}\"\nDominio: desde 0 caracteres hasta lo que quepa en memoria\nOperadores:\n\nCadenas: +\nComparación: &gt;, &gt;=, &lt;, &lt;=, ==, !=\n\n\n\n\n\n\n\nPareja de comillas simples, dobles, otras representaciones especiales\n\nDaremos preferencia a las comillas dobles\n\nContiene una cadena de cero o más caracteres en su interior\nA veces querremos representar caracteres especiales: las propias comillas, saltos de línea, tabuladores, etc.\n\nPodemos utilizar secuencias de escape para representar estos caracteres\n\nEl caracter \\ indica que el siguiente caracter es especial\n\nPara el caso de las comillas, podemos utilizar el otro tipo de comillas\n\nLas cadenas no pueden contener saltos de línea, necesitamos utilizar \\n para ello\n\ntexto0 = \"\"                                # cadena vacía\ntexto1 = \"Hola, mundo!\"                    # cadena de texto normal\ntexto2 = 'Y Arquímedes dijo: \"Eureka!\"'    # comillas simples para envolver comillas dobles\ntexto3 = \"Y Arquímedes dijo: \\\"Eureka!\\\"\"  # caracter de escape para comillas dobles\ntexto4 = \"Frase en\\ndos líneas\"            # salto de línea\n\n\n\n\n\nUna cadena de texto es una secuencia de caracteres\nDicha secuencia puede ser de cualquier longitud\n\nDesde cero caracteres (cadena vacía)\nHasta lo que quepa en memoria\n\nPython soporta cualquier caracter soportado en UCS-4\n\nCaracteres ASCII: a, A, 1, !, ?, espacio en blanco\nCaracteres especiales: \\n (salto de línea), \\t (tabulador)\nCaracteres Latin-1: á, é, í, ó, ú, ñ, ü\nCaracteres Kanji: 漢, 字, 漢字\nCaracteres Unicode: 💪, 🙈, 💩, 💦\n\n\ntexto = \"Hola, mundo! 😉\"\n\n\n\n\n\nPython utiliza UTF-8 para representar las cadenas de texto\n\nUTF-8 es un formato de codificación de caracteres que permite representar cualquier caracter Unicode\nCada caracter se representa con un número variable de bytes\nLos caracteres ASCII se representan con un byte\nLos caracteres no ASCII se representan con más de un byte\n\nLa tabla ASCII es un acuerdo de representación de caracteres en inglés\n\nCada caracter se representa con un número de 7 bits\nEjemplos: A (65), Z (90), a (97), 0 (48), ! (33)\n\nLa codificación de los caracteres no-ASCII sigue un principio similar\n\nLos detalles quedan fuera del alcance de este curso\n\n\n\n\n\n\n\n\nhttps://es.wikipedia.org/wiki/ASCII\n\n\n\n\n\n\n\n\nOperadores de cadenas de texto:\n\nConcatenación: +\n\nOperadores de comparación:\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=\n\n\nEjemplos:\ntexto1 = \"Hola\"\ntexto2 = \"mundo\"\ntexto3 = texto1 + \", \" + texto2 + \"!\"\n\ncond1  = \"Hola\" == \"hola\"  # Falso\ncond2  = \"aa\" &lt; \"ab\"       # Verdadero\n\n\n\n\n\n\n\nFunción\nDescripción\n\n\n\n\nstr()\nConversión a cadena\n\n\nord()\nValor ASCII de un carácter\n\n\nchr()\nCarácter ASCII de un valor (str)\n\n\nlen()\nLongitud de la cadena\n\n\n\nEjemplos:\ntexto = str(42)       # str: \"42\"\n\nvalor = ord(\"A\")      # int: 65\nletra = chr(65)       # str: \"A\"\nigual = chr(ord(\"A\")) # str: \"A\"\n\nlongitud = len(texto) # int: 2\n\n\n\n\n\nPython ofrece varios tipos de strings especiales\n\nTriple comilla\nRaw strings\nF-strings\n\n\n\n\n\n\nAcepta comillas simples o dobles: \"\"\"texto\"\"\", '''texto'''\n\nPermite escribir cadenas de texto multilínea\nÚtil para:\n\nDocumentar funciones, clases, módulos, etc.\nOutputs de texto extensos\n\n\n\ntexto = \"\"\"Este es un texto que ocupa varias líneas\ny se escribe con triple comilla\"\"\"\nprint(\"\"\"⠀\n    ⠀⠀⠀⡄⡀⠀⠀⠀⠀⠀⠀⠀\n    ⠀⠀⣼⣿⠇⠀⠀⠈⢿⣿⣦⠀\n    ⠀⢰⣿⣿⠀⠀⠀⠀⠀⢿⣿⡇\n    ⠀⠸⣿⣿⣷⣶⣿⣿⣿⣿⣿⡇\n    ⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⡆\n    ⠀⠀⡾⢿⣿⣿⠛⢿⣿⣿⣿⣿\n    ⠀⠀⢷⡈⣿⣿⣆⢘⣿⣿⣿⡟\n    ⠀⠀⠘⢿⣿⣿⣿⣿⣿⣿⡟⠁\n    ⠀⣀⡄⣰⣿⣿⣿⣿⣿⣿⣿⠀\n    ⠈⠛⢸⣿⣿⣿⣿⣿⣿⣿⣿⡇\n    ⠀⠀⠈⠿⣿⣿⣿⣿⣿⣿⣿⡇\n    ⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⠇\n    ⠀⠀⠀⠀⠸⣿⠁⠙⠃⢿⠟⠀\n\"\"\")\n# Credits: https://emojicombos.com/hollow-knight\n\n\n\n\n\nUna r inmediatamente antes de las comillas: r\"texto\"\n\nIgnora los caracteres de escape\nÚtil para expresiones regulares, rutas de archivos, etc.\n\n\nfichero1 =  \"C:\\\\Users\\\\usuario\\\\archivo.txt\"  # Tenemos que escapar cada barra\nfichero2 = r\"C:\\Users\\usuario\\archivo.txt\"     # La r indica que el contenide se toma literalmente\n\n\n\n\n\nUna f inmediatamente antes de las comillas: f\"texto {variable}\"\n\nPermite incluir variables dentro de una cadena de texto\nÚtil para formatear cadenas de texto\n\n\nnombre = \"Juan\"\nedad = 21\n\nsaludo1 = \"Hola, me llamo \" + nombre + \" y tengo \" + edad + \" años\"  # Concatenando\nsaludo2 = f\"Hola, me llamo {nombre} y tengo {edad} años\"             # F-string"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.html#cadenas-de-texto",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.html#cadenas-de-texto",
    "title": "Teoría 202",
    "section": "",
    "text": "Palabra reservada: str\nLiterales: \"hola\", 'hola', \"\", '', f\"hola {nombre}\"\nDominio: desde 0 caracteres hasta lo que quepa en memoria\nOperadores:\n\nCadenas: +\nComparación: &gt;, &gt;=, &lt;, &lt;=, ==, !=\n\n\n\n\n\n\n\nPareja de comillas simples, dobles, otras representaciones especiales\n\nDaremos preferencia a las comillas dobles\n\nContiene una cadena de cero o más caracteres en su interior\nA veces querremos representar caracteres especiales: las propias comillas, saltos de línea, tabuladores, etc.\n\nPodemos utilizar secuencias de escape para representar estos caracteres\n\nEl caracter \\ indica que el siguiente caracter es especial\n\nPara el caso de las comillas, podemos utilizar el otro tipo de comillas\n\nLas cadenas no pueden contener saltos de línea, necesitamos utilizar \\n para ello\n\ntexto0 = \"\"                                # cadena vacía\ntexto1 = \"Hola, mundo!\"                    # cadena de texto normal\ntexto2 = 'Y Arquímedes dijo: \"Eureka!\"'    # comillas simples para envolver comillas dobles\ntexto3 = \"Y Arquímedes dijo: \\\"Eureka!\\\"\"  # caracter de escape para comillas dobles\ntexto4 = \"Frase en\\ndos líneas\"            # salto de línea\n\n\n\n\n\nUna cadena de texto es una secuencia de caracteres\nDicha secuencia puede ser de cualquier longitud\n\nDesde cero caracteres (cadena vacía)\nHasta lo que quepa en memoria\n\nPython soporta cualquier caracter soportado en UCS-4\n\nCaracteres ASCII: a, A, 1, !, ?, espacio en blanco\nCaracteres especiales: \\n (salto de línea), \\t (tabulador)\nCaracteres Latin-1: á, é, í, ó, ú, ñ, ü\nCaracteres Kanji: 漢, 字, 漢字\nCaracteres Unicode: 💪, 🙈, 💩, 💦\n\n\ntexto = \"Hola, mundo! 😉\"\n\n\n\n\n\nPython utiliza UTF-8 para representar las cadenas de texto\n\nUTF-8 es un formato de codificación de caracteres que permite representar cualquier caracter Unicode\nCada caracter se representa con un número variable de bytes\nLos caracteres ASCII se representan con un byte\nLos caracteres no ASCII se representan con más de un byte\n\nLa tabla ASCII es un acuerdo de representación de caracteres en inglés\n\nCada caracter se representa con un número de 7 bits\nEjemplos: A (65), Z (90), a (97), 0 (48), ! (33)\n\nLa codificación de los caracteres no-ASCII sigue un principio similar\n\nLos detalles quedan fuera del alcance de este curso\n\n\n\n\n\n\n\n\nhttps://es.wikipedia.org/wiki/ASCII\n\n\n\n\n\n\n\n\nOperadores de cadenas de texto:\n\nConcatenación: +\n\nOperadores de comparación:\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=\n\n\nEjemplos:\ntexto1 = \"Hola\"\ntexto2 = \"mundo\"\ntexto3 = texto1 + \", \" + texto2 + \"!\"\n\ncond1  = \"Hola\" == \"hola\"  # Falso\ncond2  = \"aa\" &lt; \"ab\"       # Verdadero\n\n\n\n\n\n\n\nFunción\nDescripción\n\n\n\n\nstr()\nConversión a cadena\n\n\nord()\nValor ASCII de un carácter\n\n\nchr()\nCarácter ASCII de un valor (str)\n\n\nlen()\nLongitud de la cadena\n\n\n\nEjemplos:\ntexto = str(42)       # str: \"42\"\n\nvalor = ord(\"A\")      # int: 65\nletra = chr(65)       # str: \"A\"\nigual = chr(ord(\"A\")) # str: \"A\"\n\nlongitud = len(texto) # int: 2\n\n\n\n\n\nPython ofrece varios tipos de strings especiales\n\nTriple comilla\nRaw strings\nF-strings\n\n\n\n\n\n\nAcepta comillas simples o dobles: \"\"\"texto\"\"\", '''texto'''\n\nPermite escribir cadenas de texto multilínea\nÚtil para:\n\nDocumentar funciones, clases, módulos, etc.\nOutputs de texto extensos\n\n\n\ntexto = \"\"\"Este es un texto que ocupa varias líneas\ny se escribe con triple comilla\"\"\"\nprint(\"\"\"⠀\n    ⠀⠀⠀⡄⡀⠀⠀⠀⠀⠀⠀⠀\n    ⠀⠀⣼⣿⠇⠀⠀⠈⢿⣿⣦⠀\n    ⠀⢰⣿⣿⠀⠀⠀⠀⠀⢿⣿⡇\n    ⠀⠸⣿⣿⣷⣶⣿⣿⣿⣿⣿⡇\n    ⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⡆\n    ⠀⠀⡾⢿⣿⣿⠛⢿⣿⣿⣿⣿\n    ⠀⠀⢷⡈⣿⣿⣆⢘⣿⣿⣿⡟\n    ⠀⠀⠘⢿⣿⣿⣿⣿⣿⣿⡟⠁\n    ⠀⣀⡄⣰⣿⣿⣿⣿⣿⣿⣿⠀\n    ⠈⠛⢸⣿⣿⣿⣿⣿⣿⣿⣿⡇\n    ⠀⠀⠈⠿⣿⣿⣿⣿⣿⣿⣿⡇\n    ⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⠇\n    ⠀⠀⠀⠀⠸⣿⠁⠙⠃⢿⠟⠀\n\"\"\")\n# Credits: https://emojicombos.com/hollow-knight\n\n\n\n\n\nUna r inmediatamente antes de las comillas: r\"texto\"\n\nIgnora los caracteres de escape\nÚtil para expresiones regulares, rutas de archivos, etc.\n\n\nfichero1 =  \"C:\\\\Users\\\\usuario\\\\archivo.txt\"  # Tenemos que escapar cada barra\nfichero2 = r\"C:\\Users\\usuario\\archivo.txt\"     # La r indica que el contenide se toma literalmente\n\n\n\n\n\nUna f inmediatamente antes de las comillas: f\"texto {variable}\"\n\nPermite incluir variables dentro de una cadena de texto\nÚtil para formatear cadenas de texto\n\n\nnombre = \"Juan\"\nedad = 21\n\nsaludo1 = \"Hola, me llamo \" + nombre + \" y tengo \" + edad + \" años\"  # Concatenando\nsaludo2 = f\"Hola, me llamo {nombre} y tengo {edad} años\"             # F-string"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.html#booleanos",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/202_texto_y_booleanos.html#booleanos",
    "title": "Teoría 202",
    "section": "2 Booleanos",
    "text": "2 Booleanos\n\n\n2.1 Booleanos en Python\n\nPalabra reservada: bool\nLiterales: True, False\nDominio: True, False\nOperadores:\n\nLógicos: and, or, not\n\n\n\n\n\n2.2 Booleanos: Representación literal\n\nLos booleanos son un tipo de dato binario\n\nSolo pueden tomar dos valores: True o False\n\nLa primera letra mayúscula es obligatoria\n\ncond1 = True\ncond2 = False\n\n\n\n2.3 Booleanos: Dominio\n\nLos booleanos representan valores de verdad\n\nTrue representa verdadero\nFalse representa falso\n\nLos booleanos son el resultado de aserciones lógicas\n\n\n\n\n2.4 Booleanos: Operadores\n\nOperadores booleanos:\n\nConjunción: and\nDisyunción: or\nNegación: not\n\n\n\n\n2.4.1 Tabla de verdad de los operadores lógicos\n\n\nAND\n\n\n\na\nb\na and b\n\n\n\n\n✅\n✅\n✅\n\n\n✅\n❌\n❌\n\n\n❌\n✅\n❌\n\n\n❌\n❌\n❌\n\n\n\n\nOR\n\n\n\na\nb\na or b\n\n\n\n\n✅\n✅\n✅\n\n\n✅\n❌\n✅\n\n\n❌\n✅\n✅\n\n\n❌\n❌\n❌\n\n\n\n\nNOT\n\n\n\na\nnot a\n\n\n\n\n✅\n❌\n\n\n❌\n✅\n\n\n\n\n\n\n\n\n2.4.2 Ejemplos de operaciones lógicas\nha_llovido = True\nhe_fregado_el_suelo = False\n\nel_suelo_esta_mojado = ha_llovido or he_fregado_el_suelo\naprobado_practicas = True\naprobado_teoricas = True\naprobado_problemas = False\n\naprobado = aprobado_practicas and aprobado_teoricas  # Los problemas no cuentan\ntengo_leche = False\ntengo_agua = True\ntengo_pure_en_polvo = True\n\npuedo_hacer_pure = (tengo_leche or tengo_agua) and tengo_pure_en_polvo\nestoy_en_casa = False\nllega_un_paquete = True\n\nentrega_fallida = not estoy_en_casa and llega_un_paquete  # \n# El not tiene prioridad:  (not estoy_en_casa) and llega_un_paquete\n\n\n\n\n2.5 Booleanos: Funciones\n\nAunque en Python existe la función bool():\n\nNO ES ACONSEJABLE UTILIZARLA (No funciona como esperaríais)\nEvalua la veracidad de una variable depende del tipo de dato\n\nUn entero es falso si es 0\nUna cadena de texto es falsa si está vacía\n\n\nEn su lugar, para obtener valores booleanos utilizaremos siempreoperadores de comparación:\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=\n\n\nEjemplos:\n# CUIDADO\nverdadero = bool(\"True\")  # True\nfalso = bool(\"False\")     # True\n\n# CORRECTO\nvalor = \"No\"               # El usuario introduce \"Si\" o \"No\"\nverdadero = valor == \"Si\"  # False\n\n\n2.5.1 Ejemplos: El Bar Zoomer\n\nEl Bar Zoomer sólo abre los fines de semana.\nEl Bar Zoomer no admite menores, ni boomers, ni millennials.\n\nedad = 21\n\nes_mayor_de_edad = edad &gt;= 18                                                     # True\nes_zoomer = es_mayor_de_edad and edad &lt; 25                                        # True\n# es_zoomer = 18 &lt;= edad &lt; 25   # Python soporta comparaciones encadenadas\n\ndia_de_la_semana = \"Lunes\"\nes_fin_de_semana = dia_de_la_semana == \"Sábado\" or dia_de_la_semana == \"Domingo\"  # False\n\npuede_entrar = es_zoomer and es_fin_de_semana                                     # False\n\n\n\n2.5.2 Ejemplos: Derecho a beca\n\nExisten dos tipos de becas: las becas sociales y las becas de excelencia.\n\nLas becas sociales se otorgan a los nuevos estudiantes cuyos ingresos familiares no superen los 30.000€.\nLas becas de excelencia se otorgan a los estudiantes con una nota media igual o superior a 9.5.\n\n\ningresos_anuales = 500_000\nnum_matriculas = 1\nnota_media = 9.8\n\nprimera_matricula = num_matriculas == 1                        # True\ningresos_superiores = ingresos_anuales &gt; 30_000                # True\n\nbeca_social = primera_matricula and not ingresos_superiores    # False\nbeca_excelencia = nota_media &gt;= 9.5                            # True\n\nbeca = beca_social or beca_excelencia                          # True\nPropuesta: Adapta el ejemplo de las becas para que sea interactivo (print() y input()) y comprueba su funcionamiento para distintos valores de entrada."
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#fundamentos-de-python",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#fundamentos-de-python",
    "title": "Teoría 103",
    "section": "Fundamentos de Python",
    "text": "Fundamentos de Python"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#variables",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#variables",
    "title": "Teoría 103",
    "section": "Variables",
    "text": "Variables"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#asignación",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#asignación",
    "title": "Teoría 103",
    "section": "Asignación",
    "text": "Asignación"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#modelo-de-ejecución-imperativa",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#modelo-de-ejecución-imperativa",
    "title": "Teoría 103",
    "section": "Modelo de ejecución imperativa",
    "text": "Modelo de ejecución imperativa"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#entradasalida",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#entradasalida",
    "title": "Teoría 103",
    "section": "Entrada/Salida",
    "text": "Entrada/Salida"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#ejercicios",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.reveal.html#ejercicios",
    "title": "Teoría 103",
    "section": "Ejercicios",
    "text": "Ejercicios"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html",
    "title": "Teoría 103",
    "section": "",
    "text": "Programa Python: conjunto de instrucciones\n\nInstrucción: elemento mínimo de un programa, que cambia su estado\n\nLas instrucciones se separan entre sí utilizando saltos de línea\n\nSi una instrucción es muy larga, se puede dividir en varias líneas\n\n\n\nEl programa más simple en Python\n\n\n\nEfectivamente, este programa no hace nada (pero es un programa válido)"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#fundamentos-de-python",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#fundamentos-de-python",
    "title": "Teoría 103",
    "section": "",
    "text": "Programa Python: conjunto de instrucciones\n\nInstrucción: elemento mínimo de un programa, que cambia su estado\n\nLas instrucciones se separan entre sí utilizando saltos de línea\n\nSi una instrucción es muy larga, se puede dividir en varias líneas\n\n\n\nEl programa más simple en Python\n\n\n\nEfectivamente, este programa no hace nada (pero es un programa válido)"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#variables",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#variables",
    "title": "Teoría 103",
    "section": "2 Variables",
    "text": "2 Variables\n\n\n2.1 ¿Qué es una variable?\n\nUna variable es una abstracción de un dato que cambia durante la ejecución del programa\nUna variable se compone de:\n\nNombre (o identificador representativo)\nTipo de dato (o conjunto de valores que puede tomar)\nValor (o contenido actual)\n\n\nedad = 20      # Variable de tipo entero\naltura = 1.75  # Variable de tipo real\n\n\n\n2.2 Declaración (o definición) de variable\n\nA diferencia de otros lenguajes, python no requiere de una definición antes del primer uso de la variable.\n\nUsar una variable: utilizar su nombre o identificador en el código fuente\n\nUna variable será declarada en el momento en el que la usemos por primera vez\n\na = 5  # Declaración de variable\na = 7  \n\n\n\n2.3 Identificadores válidos\n\nEl identificador (nombre) de una variable debe cumplir con ciertas reglas:\n\nCombinación de letras (alfabeto inglés), números y el carácter _\n\nProhibido: espacio, !, @, #, etc.\n\nEl primer carácter no puede ser un número\nNo puede ser palabra reservada de Python:\n\nif, for, while, def, import, True, False, etc.\n\nPython distingue mayúsculas de minúsculas\n\nedad y Edad son identificadores distintas\n\n\n\n\n\n2.3.1 Recomendaciones para identificadores\n\nElige identificadores descriptivos y autoexplicativos\nUtiliza el caracter _ para separar palabras (snake_case)\nMantén un estilo uniforme en todo el programa\n\nNombrar es un arte\n\n\n\n2.3.2 Ejemplos de identificadores\n\n\nVálidos\n\nmensaje\nh12_5\n_56op\nmañana (no recomendado)\n\n\nInválidos\n\nint (palabra reservada)\nv.a (punto no permitido)\neje-x (guion no permitido)\n6hola (número al inicio)\n\n\n\n\n\n\n\n2.4 Tipos de datos\n\nPython es un lenguaje de programación muy flexible\nLas variables no están atadas a un mismo tipo de dato durante toda su existencia\n\nUna misma variable puede ser primero un número y luego una letra\n\nQue se pueda NO QUIERE DECIR QUE SE DEBA\n\nEs recomendable mantener el tipo de dato consistente en una variable\nEs tarea nuestra ser disciplinados y usar bien las variables\n\n\nSi creo una variable para guardar un número, no la usaré para otra cosa que no sea guardar números"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#asignación",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#asignación",
    "title": "Teoría 103",
    "section": "3 Asignación",
    "text": "3 Asignación\n\n\n3.1 Asignación de valores a variables\n\nLa asignación es una instrucción que cambia el valor de una variable\nEn Python, la asignación se realiza con el operador =y tiene la forma identificador = expresión\n\nIdentificador: nombre de la variable que va a recibir el valor\nExpresión: valor que se va a asignar a la variable\n\n\n# Asignamos a la variable identificada como a\n# el valor de la expresión 9\na = 9\n## Ahora a vale 9\n\n\n\n3.2 Expresiones\n\nUna expresión es una construcción que produce un valor cuando se la evalúa\nPuede ser un valor literal, una variable, una operación, etc.\n\nVeremos más detalles de esto en los próximos temas\n\n\n# Expresión literal (se evalúa como 5) \na = 5 \n\n# Expresión variable (se evalúa como el valor de a,\n# que en este momento es 5)\nb = a  \n\n# Expresión operación (se evalúa como 4)\nc = 2 + 2  \n\n# Expresión operación con variables \nd = a + b\n\n\n\n3.3 Expresiones en las asignaciones\n\nEn una asignación, la componente a la derecha del signo = es una expresión\nEl orden en el que se ejecuta es:\n\nSe evalúa el valor de la expresión\nSi la variable no existe, se crea\nSe copia ese valor en la variable\n\n\n\n\n\n3.4 Expresiones vs Instrucciones\n\nInstrucción: es una acción que realiza el programa\n\nCambia el estado del programa\n\nExpresión: es una evaluación que produce un valor\n\na = 2 + 2\n\nEl código anterior contiene:\n\n\\(1\\) instrucción de asignación\n\\(1\\) expresión de suma\n\\(2\\) expresiones literales"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#modelo-de-ejecución-imperativa",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#modelo-de-ejecución-imperativa",
    "title": "Teoría 103",
    "section": "4 Modelo de ejecución imperativa",
    "text": "4 Modelo de ejecución imperativa\n\n\n4.1 Composición secuencial de un programa\n\nEl paradigma imperativo dicta que un programa es un estado y un conjunto de instrucciones que lo modifican.\nEl orden en que las instrucciones de un programa serán ejecutadas es:\n\nSecuencial: una instrucción después de la otra\nDescendente: de arriba hacia abajo\n\n\na = 1\nb = 2\n\nLa instrucción a = 1 se ejecuta antes que b = 2\n\n\n\n4.1.1 ¿Que valores tienen a y b al final de este código?\na = 1\nb = a\na = 2"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#entradasalida",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#entradasalida",
    "title": "Teoría 103",
    "section": "5 Entrada/Salida",
    "text": "5 Entrada/Salida\n\n\n5.1 Entrada salida por consola\n\nLos programas que desarrollaremos en este curso interactuarán con el usuario a través de la consola.\nNuestros programas podrás:\n\nMostrar datos y mensajes al usuario\nLeer datos que el usuario introduzca\n\nCuando nos refiramos a las operaciones de entrada/salida hablaremos desde la perspectiva del programa:\n\nSalida: mostrar (escribir) datos al usuario\nEntrada: recibir (leer) datos del usuario\n\n\n\n\n\n5.2 Escribir en consola\n\nPara que nuestro programa python pueda escribir en la consola:\n\nDedicaremos una instrucción a invocar a la función print\nLa función print muestra el valor de una expresión en la consola\n\nSu sintaxis es print(expresión)\n\nExpresión: valor que se desea mostrar en la consola\nAsegúrate de que escribes correctamente los paréntesis\n\n\n# Imprimirá el número 2 en la consola\nprint(2)\n\n\n\n5.3 Leer de la consola\n\nPara que nuestro programa python pueda leer de la consola:\n\nInvocaremos a la función input como parte de una expresión\nLa función input devuelve el valor introducido por el usuario\n\nSu sintaxis es input()\n\n# Leerá un valor introducido por el usuario y lo almacenará en a\na = input()\n\n\n\n5.4 Leer valores numéricos\n\nLa función input siempre devuelve un valor de tipo texto\nPara convertir ese texto en un valor numérico con el que podamos operar, utilizaremos las funciones int y float\n\nint: convierte un texto en un número entero\nfloat: convierte un texto en un número real\n\nEn los próximas temas profundizaremos en el por qué de esto\n\na = int(input())\nb = a + 1"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#ejercicios",
    "href": "src/01_teoria/01_conceptos_basicos/103_fundamentos_python.html#ejercicios",
    "title": "Teoría 103",
    "section": "6 Ejercicios",
    "text": "6 Ejercicios\n\n\n¿Qué hace el siguiente código?\n\nprint(\"¿Qué tal?\")\nprint(\"Hola\")\n\n\n¿Qué hace el siguiente código?\n\nprint(\"Introduce tu nota de prácticas: \")\npracticas = int(input())\nprint(\"Introduce tu nota de examen: \")\nexamen = int(input())\nmedia = 0.7 * examen + 0.3 * practicas\nprint(\"Tu nota media es: \")\nprint(media)"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.reveal.html#que-es-la-informática",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.reveal.html#que-es-la-informática",
    "title": "Teoría 101",
    "section": "¿Que es la informática?",
    "text": "¿Que es la informática?\n\nProcesamiento de información automática\nInformación: Conjunto de datos numéricos, alfabéticos o alfanuméricos necesarios para plantear y resolver un problema\nTratamiento de la información:\n\nEntrada: Introducción de los datos del problema\nProcesamiento: Transformación de datos\nSalida: Presentación de resultados"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.reveal.html#historia-de-la-informática",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.reveal.html#historia-de-la-informática",
    "title": "Teoría 101",
    "section": "Historia de la Informática",
    "text": "Historia de la Informática"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.reveal.html#hardware",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.reveal.html#hardware",
    "title": "Teoría 101",
    "section": "Hardware",
    "text": "Hardware"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.reveal.html#software",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.reveal.html#software",
    "title": "Teoría 101",
    "section": "Software",
    "text": "Software"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.html",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.html",
    "title": "Teoría 101",
    "section": "",
    "text": "Procesamiento de información automática\nInformación: Conjunto de datos numéricos, alfabéticos o alfanuméricos necesarios para plantear y resolver un problema\nTratamiento de la información:\n\nEntrada: Introducción de los datos del problema\nProcesamiento: Transformación de datos\nSalida: Presentación de resultados\n\n\n\n\nDatos y Procesos\n\n\n\n\n\n\n\nPCs\nSupercomputadoras\nSmartphones\nElectrodomésticos\nCajeros automáticos\nConsolas\nRobots\n…"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.html#que-es-la-informática",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.html#que-es-la-informática",
    "title": "Teoría 101",
    "section": "",
    "text": "Procesamiento de información automática\nInformación: Conjunto de datos numéricos, alfabéticos o alfanuméricos necesarios para plantear y resolver un problema\nTratamiento de la información:\n\nEntrada: Introducción de los datos del problema\nProcesamiento: Transformación de datos\nSalida: Presentación de resultados\n\n\n\n\nDatos y Procesos\n\n\n\n\n\n\n\nPCs\nSupercomputadoras\nSmartphones\nElectrodomésticos\nCajeros automáticos\nConsolas\nRobots\n…"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.html#historia-de-la-informática",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.html#historia-de-la-informática",
    "title": "Teoría 101",
    "section": "2 Historia de la Informática",
    "text": "2 Historia de la Informática\n\n\n2.1 300-500 a.C.: El Ábaco\n\n\n\nPrimer dispositivo de cálculo conocido\nUtilizado para realizar operaciones básicas como suma y resta\nBase para el desarrollo de herramientas más complejas\n\n\n\n\n\n\n\n\n2.2 Siglo II a.C.: Máquina de Anticitera\n\n\n\nPrimer mecanismo conocido de engranajes complejos\nUtilizado para predecir posiciones astronómicas y eclipses\nIntroducción de conceptos de cálculo mecánico en la astronomía\n\n\n\n\n\n\n\n\n2.3 Siglos VIII-IX: Al-Juarismi\n\n\n\nIntrodujo el álgebra en su obra “Al-Kitab al-Mukhtasar fi Hisab al-Jabr wal-Muqabala”\nSentó las bases para los algoritmos y sistemas numéricos actuales.\nDesarrollo del sistema decimal y de técnicas de resolución de ecuaciones\n\n\n\n\n\n\n\n\n2.4 Siglo XVII: La Pascalina de Blaise Pascal\n\n\n\nPrimer calculador mecánico funcional\nUtilizaba ruedas dentadas para realizar sumas y restas\nInspiró futuros dispositivos de cálculo automatizado\n\n\n\n\n\n\n\n\n2.5 Siglo XIX: El Telar de Jacquard\n\n\n\nIntroducción de tarjetas perforadas para controlar patrones en telares\nBase conceptual para la programación mediante instrucciones predefinidas\nInfluencia directa en los diseños de máquinas computacionales posteriores\n\n\n \n\n\n\n\n\n2.6 Década de 1830: La Máquina Analítica de Charles Babbage\n\n\n\nPrimer diseño conceptual de un computador programable\nIncorporaba memoria, unidad aritmética y control por tarjetas perforadas\nVisionaria pero nunca construida completamente en su época\n\n\n\n\n\n\n\n\n\n\n2.7 Década de 1840: Ada Lovelace\n\n\n\nReconocida como la primera programadora\nEscribió el primer algoritmo diseñado para ejecutarse en la Máquina Analítica\nIdentificó el potencial de las máquinas más allá del cálculo numérico\n\n\n\n\n\n\n\n\n2.8 Década de 1940: Primera Generación de Computadoras\n\nBombe\nZ3\nColossus\n\n\n\n\n2.9 1939-1940: Z3\n\n\n\nDiseñada por Konrad Zuse en 1941\nPrimera computadora electromecánica programable\n\nUtilizaba relés electromeánicos\n\nUsada para ayudar en cálculos de ingeniería\n\n\n\n\n\n\n\n\n2.10 1939-1940: Máquina Bombe\n\n\n\nDiseñada por Alan Turing y Gordon Welchman\nCompuradora electromecánica\nUsada para descifrar códigos de la máquina Enigma alemana\n\nNo programable\nProbaba todas las posibles configuraciones de la máquina Enigma\n\n\n\n\n\n\n\n\n\n2.11 Década de 1943-1944: Colossus\n\n\n\nDiseñada por Tommy Flowers y el equipo de Bletchley Park\nPrimera computadora digital electrónica\n\nUtilizaba tubos de vacío (muchísimo más rápidos que los relés)\n\nUsada para descifrar códigos de la máquina Lorenz alemana\n\nLigeramente programable, pero no de propósito general\n\n\n\n\n\n\n\n\n\n2.12 1945: ENIAC\n\n\n\nPrimera computadora electrónica de propósito general\nCapaz de realizar 5,000 operaciones por segundo\nUsaba tubos de vacío, ocupaba una sala entera\n\n\n\n\n\n\n\n\n2.13 Década de 1950: EDVAC\n\n\n\nIntroducción del concepto de programa almacenado\nEvolución significativa respecto al ENIAC, más eficiente y versátil\nDatos y programas residían en la misma memoria"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.html#hardware",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.html#hardware",
    "title": "Teoría 101",
    "section": "3 Hardware",
    "text": "3 Hardware\n\n\n3.1 Sistema Binario\n\nUnidades de información\n\nBit: Dígito binario (0 o 1)\nByte: Conjunto de 8 bits\n\nBase 2\n\n\n\n2562 = 2*10^3   1101 = 1*2^3 = 1*8 = 8\n     + 5*10^2        + 1*2^2 = 1*4 = 4\n     + 6*10^1        + 0*2^1 = 0*2 = 0\n     + 2*10^0        + 1*2^0 = 1*0 = 1\n\n\n\n\n\n3.2 Representaciones en Sistema Binario\n\nRepresentación de datos\n\nNúmeros: Representación binaria de números enteros y reales\nTexto: Codificación de caracteres mediante tablas de caracteres\nImágenes: Representación de píxeles mediante valores numéricos\nVídeo: Secuencia de imágenes\nSonido: Representación de ondas sonoras mediante valores numéricos\n\n\n\n           3 = 1*2^1 + 1*2^0        =      11\n          33 = 1*2^5 + 1*2^0        =  100001\n      E (69) = 1*2^6 + 1*2^2+ 1*2^0 = 1000101\nmorado (RGB) = (2/3 rojo, 3/3 azul)\n             = (2,0,3) = (10,00,11) =  100011\n\n\n\n\n3.3 Modelo de Von Neumann\n\n\n\nModelo Von Neumann\n\n\n\n\n\n3.4 Partes de un Computador\n\n\n\nProcesador (CPU)\n\nUnidad de control (CU)\nUnidad aritmético-lógica (ALU)\n\nMemoria\n\nGran velocidad de acceso\nRAM o ROM: Volátil o permanente\n\nAlmacenamiento\n\nDisco duro, SSD, etc.\nAlmacenamiento permanente\n\n\n\n\nDispositivos de Entrada/Salida\n\nPeriféricos para interactuar con la computadora\nTransferecia a través de buses de datos\n\nPCI, USB, etc.\n\n\n\n\n\n\n\n\n3.5 Partes de un Computador\n\n\n\nPartes de un Computador\n\n\n\n\n\nDestacar los paralelismos entre la máquina analítica de Babbage y los computadores actuales. Diferencias: - The Store: Memoria RAM o Disco - The Mill: CPU - The Steam engine: Fuente de alimentación - The Printer: Salida (dispositivos de salida) - Opetacion Cards, Variable Cards and Number Cards: Software\n\n\n\n\n3.6 Jerarquía de Memoria\n\n\n\nExisten dos reglas fundamentales:\n\nA mayor capacidad, menor velocidad\nA mayor velocidad, mayor coste\n\nPor ello, se utilizan distintos tipos de memoria\n\nRegistros: Memoria interna del procesador\nMemoria caché: Memoria de alta velocidad\nMemoria principal: Memoria RAM\nMemoria secundaria: Almacenamiento permanente"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/101_introducción.html#software",
    "href": "src/01_teoria/01_conceptos_basicos/101_introducción.html#software",
    "title": "Teoría 101",
    "section": "4 Software",
    "text": "4 Software\n\n\n4.1 Software\n\nLa propiedad más valiosa de un computador es su capacidad para ejecutar distintos programas: programable\nSoftware: Conjunto de programas y datos que controlan el funcionamiento de un computador\n\nUn programa permite automatizar una tarea\n\nEl software permite abstraer el hardware\n\nUn programa puede leer un fichero esté en un disco duro o en un USB\n\n\n\n\n\n4.2 Clasificación del software\n\nSoftware de sistema: Controla el hardware y proporciona servicios a los programas de aplicación\n\nSistemas operativos: Windows, Linux, macOS\nControladores de dispositivos: Drivers\n\nSoftware de aplicación: Realiza tareas específicas para el usuario\n\nOfimática: Microsoft Office, LibreOffice\nMultimedia: VLC, Photoshop\nNavegadores web: Chrome, Firefox\n\n\n\n\n\n4.3 La abstracción en la informática\n\nAbstracción: Proceso de ocultar detalles de implementación y mostrar solo las características esenciales de un objeto\nBajo nivel: Representación cercana al hardware\n\nOperaciones directas sobre la memoria\nDependientes del hardware\n\nAlto nivel: Representación al problema\n\nAbstracciones como variables, objetos, funciones, etc.\nPortables entre distintos hardwares"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fundamentos de informática",
    "section": "",
    "text": "01_teoria/00_presentacion/ Presentación de la Asignatura - Información general \n\n\n01_teoria/01_conceptos_basicos/ Teoría 101 - Computadores y Lenguajes \n\n\n01_teoria/01_conceptos_basicos/ Teoría 102 - Lenguajes \n\n\n01_teoria/01_conceptos_basicos/ Teoría 103 - Python \n\n\n01_teoria/02_tipos_de_datos_basicos/ Teoría 201 - Tipos Numerales \n\n\n01_teoria/02_tipos_de_datos_basicos/ Teoría 202 - Texto y Booleanos \n\n\n01_teoria/03_composicion/ Teoría 301 - Composición condicional \n\n\n01_teoria/03_composicion/ Teoría 302 - Composición Iterativa I \n\n\n01_teoria/03_composicion/ Teoría 303 - Composición Iterativa II \n\n\n01_teoria/03_composicion/ Teoría 304 - Composición Iterativa III \n\n\n01_teoria/03_composicion/ Teoría 305 - Composición Iterativa IV \n\n\n01_teoria/03_composicion/ Teoría 306 - Composición Iterativa V \n\n\n01_teoria/04_modularizacion_de_codigo/ Teoría 401 - Funciones I \n\n\n02_problemas/ Problemas 1 - Fundamentos \n\n\n02_problemas/ Problemas 2 - Tipos Numéricos \n\n\n02_problemas/ Problemas 3 - Composición condicional \n\n\n02_problemas/ Problemas 4 - Composición iterativa: while \n\n\n02_problemas/ Problemas 5 - Composición iterativa: for y while \n\n\n02_problemas/ Problemas 6 - Funciones I \n\n\n03_practicas/p0/ Práctica 0 - Introducción \n\n\n03_practicas/p1/ Práctica 1 - Tipos Primitivos \n\n\n03_practicas/p2/ Práctica 2 - Composición condicional \n\n\n03_practicas/p3/ Práctica 3 - Composición iterativa \n\n\n\nNo hay resultados"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.html",
    "href": "src/01_teoria/00_presentacion/000_presentación.html",
    "title": "Presentación de la Asignatura",
    "section": "",
    "text": "Sergio Martín Segura (segura@unizar.es)\n\nTeoría, problemas y prácticas\nDespacho: L2.09, Ada Byron\n\nMiguel Ángel Latre Abadía (latre@unizar.es)\n\nPrácticas\nDespacho: D2.22, Ada Byron\n\n\nTutorías: Consultar enlace en Moodle"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.html#profesores",
    "href": "src/01_teoria/00_presentacion/000_presentación.html#profesores",
    "title": "Presentación de la Asignatura",
    "section": "",
    "text": "Sergio Martín Segura (segura@unizar.es)\n\nTeoría, problemas y prácticas\nDespacho: L2.09, Ada Byron\n\nMiguel Ángel Latre Abadía (latre@unizar.es)\n\nPrácticas\nDespacho: D2.22, Ada Byron\n\n\nTutorías: Consultar enlace en Moodle"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.html#organización",
    "href": "src/01_teoria/00_presentacion/000_presentación.html#organización",
    "title": "Presentación de la Asignatura",
    "section": "2 Organización",
    "text": "2 Organización\n\nClases teóricas: 2 horas semanales\nClases de problemas: 1 hora semanal\nPrácticas de laboratorio: 2 horas cada dos semanas\n\n\n\n2.1 Sesiones de teoría\n\nIntroducción de conceptos fundamentales\nResolución magistral de ejercicios de ejemplo\n\n\n\n\n2.2 Sesiones de problemas\n\nResolución autónoma de ejercicios sencillos\n\nSe puede traer ordenador\nSe aconseja resolver los ejercicios en papel\n\n\n\n\n\n2.3 Sesiones de prácticas\n\nResolución autónoma de ejercicios complejos\n\nSe puede traer ordenador personal o usar los del laboratorio\n\nSe realizarán 7 sesiones.\n\nP0: No evaluable\nP1 a P6: Evaluables\n\nAlumnos divididos por grupos\n\nGrupos pre-asignados por la coordinación del grado\nCada grupo tiene un profesor asignado\n\nResolución individual\nEntregas con fecha común\n\nImplica traer preparada la práctica a la sesión"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.html#evaluación-final",
    "href": "src/01_teoria/00_presentacion/000_presentación.html#evaluación-final",
    "title": "Presentación de la Asignatura",
    "section": "3 Evaluación final",
    "text": "3 Evaluación final\n\nLa nota final, tal cual indica la guía docente, se calcula:\n\n\\(70\\%\\) Examen escrito (mínimo \\(5\\))\n\\(30\\%\\) Nota de prácticas (dos opciones):\n\nEntregas de prácticas\nExamen práctico final (anula la nota de entregas)\n\n\nSe deberá obtener una nota mínima de \\(5\\) ponderada para aprobar la asignatura\nSegunda convocatoria\n\nExamen escrito + Examen práctico final\nMismas ponderaciones\n\n\n\n\n3.1 Examen escrito\n\nEscrito en papel\nResolución de problemas\n\n3 o 4 ejercicios, según dificultad\n\nEvaluación de los ejercicios\n\nSe valorará la corrección y la claridad de la solución\nError de concepto grave: \\(0\\)\n\nProhibido cualquier material de consulta o dispositivo de comunicación.\n\nEn caso de plagio, se abrirá un expediente y la calificación quedará pendiente de su resolución.\n\n\n\n\n\n3.2 Entregas de Prácticas\n\nSe entregarán 6 prácticas evaluables\nLas entregas se realizarán a través de Moodle\n\nNo se admitirán entregas fuera de plazo\nNo se admitirán entregas por otro medio que no sea Moodle.\n\nEn caso de plagio, se abrirá un expediente y la calificación quedará pendiente de su resolución.\n\n\n\n\n3.3 Examen práctico final\n\nVoluntario\nSu realización anula la nota de las entregas\nNo se recomienda esta opción frente a las entregas continuas"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.html#dudas",
    "href": "src/01_teoria/00_presentacion/000_presentación.html#dudas",
    "title": "Presentación de la Asignatura",
    "section": "4 ¿Dudas?",
    "text": "4 ¿Dudas?"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.reveal.html#profesores",
    "href": "src/01_teoria/00_presentacion/000_presentación.reveal.html#profesores",
    "title": "Presentación de la Asignatura",
    "section": "Profesores",
    "text": "Profesores\n\nSergio Martín Segura (segura@unizar.es)\n\nTeoría, problemas y prácticas\nDespacho: L2.09, Ada Byron\n\nMiguel Ángel Latre Abadía (latre@unizar.es)\n\nPrácticas\nDespacho: D2.22, Ada Byron\n\n\nTutorías: Consultar enlace en Moodle"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.reveal.html#organización",
    "href": "src/01_teoria/00_presentacion/000_presentación.reveal.html#organización",
    "title": "Presentación de la Asignatura",
    "section": "Organización",
    "text": "Organización\n\nClases teóricas: 2 horas semanales\nClases de problemas: 1 hora semanal\nPrácticas de laboratorio: 2 horas cada dos semanas"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.reveal.html#evaluación-final",
    "href": "src/01_teoria/00_presentacion/000_presentación.reveal.html#evaluación-final",
    "title": "Presentación de la Asignatura",
    "section": "Evaluación final",
    "text": "Evaluación final\n\nLa nota final, tal cual indica la guía docente, se calcula:\n\n\\(70\\%\\) Examen escrito (mínimo \\(5\\))\n\\(30\\%\\) Nota de prácticas (dos opciones):\n\nEntregas de prácticas\nExamen práctico final (anula la nota de entregas)\n\n\nSe deberá obtener una nota mínima de \\(5\\) ponderada para aprobar la asignatura\nSegunda convocatoria\n\nExamen escrito + Examen práctico final\nMismas ponderaciones"
  },
  {
    "objectID": "src/01_teoria/00_presentacion/000_presentación.reveal.html#dudas",
    "href": "src/01_teoria/00_presentacion/000_presentación.reveal.html#dudas",
    "title": "Presentación de la Asignatura",
    "section": "¿Dudas?",
    "text": "¿Dudas?"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html",
    "title": "Teoría 102",
    "section": "",
    "text": "Descripción detallada de cómo resolver un determinado problema\nSecuencia de acciones para obtener la solución al problema\nConjunto de instrucciones que se ejecutan en un orden determinado\n\n\n\n¿Cómo cambiar las pilas del mando de la TV?\n\nTomar el mando de la TV\nLocalizar la tapa de las pilas\nQuitar el tornillo (si tiene)\nAbrir la tapa\nQuitar las pilas viejas\nColocar las pilas nuevas\nColocar la tapa\nApretar el tornillo (si tiene)\n\n\n\n\n\n\n\nDeclaración precisa de condiciones de partida: entrada\nEspecificación del estado final: salida\nDescripción detallada de los pasos individuales\n\nOperaciones simples que ayudan en la progresión hacia el estado final\n\n\n\n\n\n\n\nPrecisión : Expresarse de forma no ambigua\nDeterminismo : Mismo estado final para las mismas entradas\nFinitud : Tener una descripción finita\n\n\n\n\n\n\nProblemas ambiguos\nProblemas con demasiados pasos para acabar\nProblemas matemáticamente imposibles"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html#algoritmo",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html#algoritmo",
    "title": "Teoría 102",
    "section": "",
    "text": "Descripción detallada de cómo resolver un determinado problema\nSecuencia de acciones para obtener la solución al problema\nConjunto de instrucciones que se ejecutan en un orden determinado\n\n\n\n¿Cómo cambiar las pilas del mando de la TV?\n\nTomar el mando de la TV\nLocalizar la tapa de las pilas\nQuitar el tornillo (si tiene)\nAbrir la tapa\nQuitar las pilas viejas\nColocar las pilas nuevas\nColocar la tapa\nApretar el tornillo (si tiene)\n\n\n\n\n\n\n\nDeclaración precisa de condiciones de partida: entrada\nEspecificación del estado final: salida\nDescripción detallada de los pasos individuales\n\nOperaciones simples que ayudan en la progresión hacia el estado final\n\n\n\n\n\n\n\nPrecisión : Expresarse de forma no ambigua\nDeterminismo : Mismo estado final para las mismas entradas\nFinitud : Tener una descripción finita\n\n\n\n\n\n\nProblemas ambiguos\nProblemas con demasiados pasos para acabar\nProblemas matemáticamente imposibles"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html#lenguajes-de-programación",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html#lenguajes-de-programación",
    "title": "Teoría 102",
    "section": "2 Lenguajes de programación",
    "text": "2 Lenguajes de programación\n\n\nUn lenguaje de programación es\n\nun lenguaje formal que\nespecifica una serie de instrucciones que,\nal ser ejecutadas por un ordenador,\npermiten realizar una tarea concreta\n\n\nEl idioma en el que los humanos se comunican con las máquinas\n\n\n2.1 Estilos de programación\n\nDiferentes estilos: imperativa, funcional, declarativa, etc.\n\nEn esta asignatura, nos centraremos en la programación imperativa\n\nProgramación imperativa: Estado + Instrucciones\n\nEstado: conjunto de variables que definen de manera unívoca la situación de un sistema\nInstrucciones: operaciones que modifican el estado del programa\nCada instrucción ayuda a la progresión hacia el estado final\n\n\n\n\n\n2.2 Niveles de lenguajes de programación\n\nUn computador solo entiende instrucciones sencillas:\n\nISA (Instruction Set Architecture): Es el conjunto de instrucciones que un procesador puede ejecutar\nCada arquitectura de procesador tiene su propia ISA\n\nEstas instrucciones básicas bastan para construir programas complejos\nSegún su nivel de abstracción:\n\nLenguajes de bajo nivel se encuentran cerca del lenguaje de la máquina\nLenguajes más sofisticados (de alto nivel) buscan acercar la programación al lenguaje humano\n\n\n\n\n2.2.1 Código máquina\n\n\n\nLenguaje que entiende el ordenador: código máquina\nAnteriormente, los programas se escribían directamente en codificación binaria (ejemplo: perforando tarjetas)\n\nAgujero = 1, sin agujero = 0\nErrores frecuentes, muy difíciles de encontrar y corregir\nSe programaba directamente en base al hardware a usar\nUn programa escrito para un hardware no es compatible con otro diferente\n\nPoco versátil\n\n\n\n\n\n\n\nTarjeta Perforada\n\n\n\n\n\n\n\n2.2.2 Lenguaje ensamblador\n\n\n\nPermite escribir instrucciones del procesador y representar los datos con identificadores más entendibles por el programador\nSin embargo, todavía es difícil de entender (bajo nivel)\nTodavía está condicionado por el hardware a usar:\n\nDiferentes máquinas = diferentes programas\nPoco versátil\n\n\n\n\n\n\nCódigo ensamblador\n\n\n\n\n\n\n\n2.2.3 Lenguajes de alto nivel\n\n\n\nSoportan abstracciones que entiende el programador,¡pero no la máquina!\nMás fáciles de utilizar para programar\nNo dependen de la máquina utilizada\nMenos eficientes que los de bajo nivel\nNecesitan compiladores/traductores al lenguaje máquina\nFacilitan detección de errores\n\n\ndef suma(a, b):\n    return a + b\n\n\n\n\n\n2.2.4 Primer lenguaje de alto nivel: FORTRAN, 1957\n\nFORTRAN (FORmula TRANslation): John Backus, 1957\n\nCódigo fuente: texto escrito en lenguaje de alto nivel (texto plano)\nCompilador: traduce el código fuente a lenguaje máquina\n\nAún se utiliza en:\n\nCiencia e ingeniería\nFinanza\n\n\n\n\n\n\n2.3 Evolución de los lenguajes\n\n\n\nhttps://www.cs.fsu.edu/~engelen/courses/COP402004/"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html#lenguajes-de-alto-nivel-1",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html#lenguajes-de-alto-nivel-1",
    "title": "Teoría 102",
    "section": "3 Lenguajes de alto nivel",
    "text": "3 Lenguajes de alto nivel\n\n\n3.1 Tipos de lenguajes de alto nivel\n\n\nLenguajes compilados\n\nLa traducción se realiza una sola vez durante la compilación\nDurante la ejecución, no se requiere el código fuente\nCada plataforma requiere su propia compilación\nUsos: sistemas operativos, videojuegos, edición de vídeo…\nEjemplos: Pascal, Ada, C/C++, Fortran…\n\n\nLenguajes interpretados\n\nLa traducción se realiza cada vez que se ejecuta el programa\nUn intérprete interpreta y ejecuta las instrucciones: más lento\nEl mismo programa sirve en múltiples plataformas: portabilidad\nUsos: aplicaciones web, sistemas multiplataforma, telfs. móviles…\nEjemplos: Python, Perl, PHP, Scratch…\n\n\n\n\n\n\n3.2 Compilador\n\nCódigo fuente \\(\\rightarrow\\) Aplicación ejecutable\nRequiere tres elementos: un compilador, un ensamblador y un enlazador\n\nCompilador: Código escrito \\(\\rightarrow\\) Código ensamblador\nEnsamblador: Código ensamblador \\(\\rightarrow\\) Código máquina (ficheros objeto)\nEnlazador: Código máquina (ficheros objeto) \\(\\rightarrow\\) Código maquina ejecutable\n\nEl compilador, no sólo traduce el código, sino que también verifica:\n\nRevisión léxica (¿usa las palabras reservadas correctamente?)\nRevisión sintáctica (¿la frase es gramaticalmente correcta?)\nRevisión semántica (¿tiene sentido la frase?)\n\n\n\n\n\n3.3 Interprete\n\nCódigo fuente \\(\\rightarrow\\) Ejecución\nSólo requiere un elemento:\n\nInterprete: lee el código fuente y lo ejecuta directamente\n\nVentajas:\n\nPortabilidad: no es necesario compilar para cada plataforma\nFacilidad de depuración: errores más fáciles de encontrar\nFlexibilidad: permite ejecutar código de forma interactiva"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html#entorno-integrado-de-desarrollo",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.html#entorno-integrado-de-desarrollo",
    "title": "Teoría 102",
    "section": "4 Entorno Integrado de Desarrollo",
    "text": "4 Entorno Integrado de Desarrollo\n\n\n4.1 Integrated Development Environment (IDE)\nAplicaciones integradas compuestas por:\n\nUn editor avanzado de código fuente\n\nResalta las palabras reservadas\nGestiona las sangrías del texto\n\nUn intérprete o compilador\nUna consola o terminal para ejecutar comandos\n[Opcional] Un depurador integrado (no lo veremos en esta asignatura)\n\n\n\n\n4.2 Proceso de trabajo\n\nDiseño de una solución al problema\nCodificación de la solución\nEjecución del programa\nVerificación del resultado\nMientras hay errores\nCorrección de errores\nVolver al paso 3"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.reveal.html#algoritmo",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.reveal.html#algoritmo",
    "title": "Teoría 102",
    "section": "Algoritmo",
    "text": "Algoritmo"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.reveal.html#lenguajes-de-programación",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.reveal.html#lenguajes-de-programación",
    "title": "Teoría 102",
    "section": "Lenguajes de programación",
    "text": "Lenguajes de programación"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.reveal.html#lenguajes-de-alto-nivel-1",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.reveal.html#lenguajes-de-alto-nivel-1",
    "title": "Teoría 102",
    "section": "Lenguajes de alto nivel",
    "text": "Lenguajes de alto nivel"
  },
  {
    "objectID": "src/01_teoria/01_conceptos_basicos/102_lenguajes.reveal.html#entorno-integrado-de-desarrollo",
    "href": "src/01_teoria/01_conceptos_basicos/102_lenguajes.reveal.html#entorno-integrado-de-desarrollo",
    "title": "Teoría 102",
    "section": "Entorno Integrado de Desarrollo",
    "text": "Entorno Integrado de Desarrollo"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html",
    "title": "Teoría 201",
    "section": "",
    "text": "Todos los lenguajes cuentan con una serie de tipos básicos.\nLos tipos básicos de Python que estudiaremos son:\n\nEnteros: para representar números enteros\nReales: para representar números reales\nBooleanos: para representar valores de cierto o falso\nTexto: para representar cadenas de caracteres\n\n\n\n\n\n\n\nSu palabra reservada\n\nint, float, etc.\n\nSus literales\n\n¿un número real se escribe 1,7 o 1.7?\n\nSu dominio (rango de valores)\n\n¿puedo representar un D.N.I. con un int?\n\nSus operaciones disponibles\n\n¿puedo sumar números enteros?\n\n\n\n\n\n\nEl dominio de un tipo de dato es el conjunto de valores que puede representar\nA diferencia de las matemáticas, en programación:\n\nTodos los tipos de datos tienen un dominio finito\n\nEl tamaño de un tipo de dato determina su dominio\n\nUn tipo de dato que requiere más bits podrá representar más valores\n\n\n\n\n\n\n\n\nRecordad que Python es un lenguaje de tipado dinámico\n\nNo es necesario declarar el tipo de una variable\nLa palabra reservada de cada tipo será útil para operaciones específicas\n\n\nedad = 21  # Python infiere que edad es un entero (int)\n\n\n\n\n\n\nEn VSCode puedes colocar el puntero de tu ratón (hover) sobre una variable para recibir una pista sobre su tipo."
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#tipos-de-datos-en-python",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#tipos-de-datos-en-python",
    "title": "Teoría 201",
    "section": "",
    "text": "Todos los lenguajes cuentan con una serie de tipos básicos.\nLos tipos básicos de Python que estudiaremos son:\n\nEnteros: para representar números enteros\nReales: para representar números reales\nBooleanos: para representar valores de cierto o falso\nTexto: para representar cadenas de caracteres\n\n\n\n\n\n\n\nSu palabra reservada\n\nint, float, etc.\n\nSus literales\n\n¿un número real se escribe 1,7 o 1.7?\n\nSu dominio (rango de valores)\n\n¿puedo representar un D.N.I. con un int?\n\nSus operaciones disponibles\n\n¿puedo sumar números enteros?\n\n\n\n\n\n\nEl dominio de un tipo de dato es el conjunto de valores que puede representar\nA diferencia de las matemáticas, en programación:\n\nTodos los tipos de datos tienen un dominio finito\n\nEl tamaño de un tipo de dato determina su dominio\n\nUn tipo de dato que requiere más bits podrá representar más valores\n\n\n\n\n\n\n\n\nRecordad que Python es un lenguaje de tipado dinámico\n\nNo es necesario declarar el tipo de una variable\nLa palabra reservada de cada tipo será útil para operaciones específicas\n\n\nedad = 21  # Python infiere que edad es un entero (int)\n\n\n\n\n\n\nEn VSCode puedes colocar el puntero de tu ratón (hover) sobre una variable para recibir una pista sobre su tipo."
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#enteros",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#enteros",
    "title": "Teoría 201",
    "section": "0.2 Enteros",
    "text": "0.2 Enteros\n\n\n0.2.1 Números enteros en Python\n\nPalabra reservada: int\nLiterales: 1, -3, 0, 1, 3_000_000, 2E3\nDominio: depende de la arquitectura de la máquina\nOperadores:\n\nAritméticos: +, -, *, /, //, %, **\nComparación: &gt;, &gt;=, &lt;, &lt;=, ==, !=\n\n\n\n\n\n0.2.2 Enteros: Representación literal\n\nSecuencia de uno o más dígitos (caracteres 0, 1, …, 9)\nPueden ir precedidos por un signo (+ o -)\nBarras bajas (_) para separar dígitos\nPython admite notación científica\nNo se permiten ceros a la izquierda\n\nb = 3    \nc = -523\nc = +444\nd = 2\ne = 4_0_0\nf = 2E3\n\n\n\n0.2.3 Enteros: Dominio\n\nEn matemáticas:\n\nDominio \\([-\\infty,+\\infty]\\)\n\nEn informática:\n\nEntre un mínimo y un máximo\nDependen de la arquitectura de la máquina\n\n\n\n\n0.2.3.1 Enteros: Dominio en otros lenguajes\n\n\n\n\n\n\n\n\nPalabra clave\nTipo de dato\nTamaño (en bits)\n\n\n\n\nshort\nentero\n16\n\n\nint\nentero\n32\n\n\nlong\nentero\n32\n\n\nlong long\nentero\n64\n\n\n\n\n\n\n0.2.3.2 Enteros: Dominio en python\n\nEn Python, todos los tipos de enteros están unificados en int\n\n\n\n\n\n0.2.4 Enteros: Operadores\n\nOperadores aritméticos:\n\nSuma: +\nResta: -\nMultiplicación: *\nDivisión: /\nDivisión entera: //\nMódulo (resto de la división): % ¡Ojo!\nPotencia: **\n\nOperadores de comparación:\n\nMayor estricto: &gt;\nMayor o igual: &gt;=\nMenor estricto: &lt;\nMenor o igual: &lt;=\nIgualdad: == ¡Atención!\nDesigualdad: !="
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#funciones-numéricas",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#funciones-numéricas",
    "title": "Teoría 201",
    "section": "1.1 Funciones numéricas",
    "text": "1.1 Funciones numéricas\n\n\n1.1.1 Funciones: Breve introducción\n\nUna función es un bloque de código que realiza una tarea específica\nDe momento, no vamos a preocuparnos por cómo se definen,\n\nsino por cómo se utilizan\n\nPara ejecutar una función, se ha de invocar o llamar a la función\n\nSe hace escribiendo el nombre de la función seguido de paréntesis ()\nSi la función requiere argumentos, se escriben dentro de los paréntesis\n\n\nprint(\"Hola, mundo!\")  # La función se llama print, y recibe un argumento\n\n\n\n1.1.2 Bibliotecas (libraries) de Python\n\nUno de los principios fundamentales del desarrollo software es la reutilización\nFuncionalidades comunes han sido ya implementadas por otros\nAlgunas de estas funcionalidades existen disponibles en el propio lenguaje\n\nprint() o input()\n\nAlgunas de estas funcionalidades han sido integradas por defecto en el intérprete de Python.\n\nEl conjunto de funcionalidades incorporadas forma parte de la Standard Library (stdlib).\nExisten muchas otras funciones, algunas de las cuales usaremos con frecuencia.\n\nPara utilizar una función de alguna de estas bibliotecas, debemos importarla.\n\nimport math  # importa la biblioteca math\n\nmath.abs(-3)  # invoca la función abs de la biblioteca math\n\n\n\n1.1.3 Funciones numéricas nativas y de la stdlib\n\n\n\nBiblioteca\nInvocación\nDescripción\n\n\n\n\nnativa\nint(x)\nConvierte la entrada a entero\n\n\nnativa\nfloat(x)\nConvierte la entrada a real\n\n\nnativa\nabs(x)\nValor absoluto\n\n\nnativa\nround(x)\nRedondeo\n\n\nmath\nmath.sqrt(x)\nRaíz cuadrada\n\n\nmath\nmath.sin(x)\nSeno\n\n\nmath\nmath.cos(x)\nCoseno\n\n\nmath\nmath.atan(x)\nArcotangente\n\n\nmath\nmath.log(x)\nLogaritmo\n\n\nmath\nmath.exp(x)\nExponencial\n\n\nmath\nmath.floor(x)\nEntero por defecto\n\n\nmath\nmath.ceil(x)\nEntero por exceso"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#expresiones-avanzadas-con-números",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#expresiones-avanzadas-con-números",
    "title": "Teoría 201",
    "section": "1.2 Expresiones avanzadas con números",
    "text": "1.2 Expresiones avanzadas con números\n\n\n1.2.1 Tipos de los operandos y resultados\n\nCada operación está compuesta por una serie de operandos y genera un resultado\n\nEj: 3 + 4 es una expresión que toma dos int y devuelve un int\n\nLa mayoría de operadores aritméticos permiten combinar operandos de diferentes tipos\n\nEj: 3 + 4.0 es una expresión que toma un int y un float y devuelve un float\n\nAlgunas operaciones toman operandos de un tipo y devuelven un resultado de otro tipo\n\nEj: 3 / 4 es una expresión que toma dos int y devuelve un float\n\nAlgunas funciones numéricas requieren operandos de un tipo específico (un int)\n\nEj: math.factorial(3) requiere un int y devuelve un int\n\nRecuerda que:\n\nfloat() convierte cualquier int en un float equivalente\nint() elimina los decimales de un float y lo convierte en un int"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#ejercicios",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.html#ejercicios",
    "title": "Teoría 201",
    "section": "1.3 Ejercicios",
    "text": "1.3 Ejercicios\n\n¿De qué tipo es cada una de las siguientes variables?\na = 3 + 2.1\nb = 3 / 2\nc = 3 // 2\nd = 3 ** 2\ne = int(2.1)\nf = round(2.1)\ng = math.sqrt(4)\nh = int(a) * c * d"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#tipos-de-datos-en-python",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#tipos-de-datos-en-python",
    "title": "Teoría 201",
    "section": "Tipos de datos en Python",
    "text": "Tipos de datos en Python"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#enteros",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#enteros",
    "title": "Teoría 201",
    "section": "Enteros",
    "text": "Enteros"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#funciones-numéricas",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#funciones-numéricas",
    "title": "Teoría 201",
    "section": "Funciones numéricas",
    "text": "Funciones numéricas"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#expresiones-avanzadas-con-números",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#expresiones-avanzadas-con-números",
    "title": "Teoría 201",
    "section": "Expresiones avanzadas con números",
    "text": "Expresiones avanzadas con números"
  },
  {
    "objectID": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#ejercicios",
    "href": "src/01_teoria/02_tipos_de_datos_basicos/201_tipos_numerales.reveal.html#ejercicios",
    "title": "Teoría 201",
    "section": "Ejercicios",
    "text": "Ejercicios"
  },
  {
    "objectID": "src/01_teoria/03_composicion/301_composicion_condicional.html",
    "href": "src/01_teoria/03_composicion/301_composicion_condicional.html",
    "title": "Teoría 301",
    "section": "",
    "text": "Hasta ahora hemos visto cómo componer programas a través de secuencias de instrucciones\nEstas secuencias se ejecutan de manera lineal, una detrás de otra\nEsto se denomina composición secuencial\n\nNo todos los programas pueden ser escritos de manera secuencial\nprint(\"Hola\")\nprint(\"Qué tal?\")\nprint(\"Yo bien\")\nprint(\"Adiós\")\n\n\n\n\n\n\n\nEscribe un programa Python que pida al usuario un número y muestre si es par o impar:\nEscriba un número:\n4\nEl número 4 es par\nEscriba un número:\n5\nEl número 4 es impar\n\n\n\n\nEscribe un programa Python que pida al usuario dos números y muestre su división:\nEscriba un número:\n4\nEscriba otro número:\n2\n4 / 2 = 2\nEscriba un número:\n4\nEscriba otro número:\n0\nNo se puede dividir por cero!\n\n\n\n\nEscribe un programa Python que dado los coeficientes de una ecuación de segundo grado, muestre sus soluciones:\n\n\nEscriba el coeficiente a:\n1\nEscriba el coeficiente b:\n-3\nEscriba el coeficiente c:\n2\nx1 = 2.0, x2 = 1.0\n\nEscriba el coeficiente a:\n1\nEscriba el coeficiente b:\n-2\nEscriba el coeficiente c:\n1\nx1 = 1.0\n\nEscriba el coeficiente a:\n1\nEscriba el coeficiente b:\n1\nEscriba el coeficiente c:\n1\nNo reales\n\n\n\n\n\n\n\n\nTodos estos programas tienen algo en común:\n\nEn función de una condición, se deberán ejecutar unas acciones y otras\nExiste al menos una decisión que tomar"
  },
  {
    "objectID": "src/01_teoria/03_composicion/301_composicion_condicional.html#límites-de-la-composición-secuencial",
    "href": "src/01_teoria/03_composicion/301_composicion_condicional.html#límites-de-la-composición-secuencial",
    "title": "Teoría 301",
    "section": "",
    "text": "Hasta ahora hemos visto cómo componer programas a través de secuencias de instrucciones\nEstas secuencias se ejecutan de manera lineal, una detrás de otra\nEsto se denomina composición secuencial\n\nNo todos los programas pueden ser escritos de manera secuencial\nprint(\"Hola\")\nprint(\"Qué tal?\")\nprint(\"Yo bien\")\nprint(\"Adiós\")\n\n\n\n\n\n\n\nEscribe un programa Python que pida al usuario un número y muestre si es par o impar:\nEscriba un número:\n4\nEl número 4 es par\nEscriba un número:\n5\nEl número 4 es impar\n\n\n\n\nEscribe un programa Python que pida al usuario dos números y muestre su división:\nEscriba un número:\n4\nEscriba otro número:\n2\n4 / 2 = 2\nEscriba un número:\n4\nEscriba otro número:\n0\nNo se puede dividir por cero!\n\n\n\n\nEscribe un programa Python que dado los coeficientes de una ecuación de segundo grado, muestre sus soluciones:\n\n\nEscriba el coeficiente a:\n1\nEscriba el coeficiente b:\n-3\nEscriba el coeficiente c:\n2\nx1 = 2.0, x2 = 1.0\n\nEscriba el coeficiente a:\n1\nEscriba el coeficiente b:\n-2\nEscriba el coeficiente c:\n1\nx1 = 1.0\n\nEscriba el coeficiente a:\n1\nEscriba el coeficiente b:\n1\nEscriba el coeficiente c:\n1\nNo reales\n\n\n\n\n\n\n\n\nTodos estos programas tienen algo en común:\n\nEn función de una condición, se deberán ejecutar unas acciones y otras\nExiste al menos una decisión que tomar"
  },
  {
    "objectID": "src/01_teoria/03_composicion/301_composicion_condicional.html#composición-condicional",
    "href": "src/01_teoria/03_composicion/301_composicion_condicional.html#composición-condicional",
    "title": "Teoría 301",
    "section": "2 Composición condicional",
    "text": "2 Composición condicional\n\n\n2.1 Composición condicional: concepto\n\nLa composición condicional es una estructura de control que permite tomar decisiones en función de una condición.\nExisten distintas formas de conseguir esto en python:\n\nif, if-else, if-elif-else\n\n\n\n\n\n2.2 Composición condicional: if\n\n\n\nLa estructura if permite condicionar la ejecución de un bloque de instrucciones si se cumple una condición.\n\nEvalúa una expresión lógica (valor booleano)\nSi el valor es True: ejecuta el bloque.\nSi el valor es False: no ejecuta el bloque.\n\nEl bloque de instrucciones que se ejecuta condicionalmente se identifica por su indentación.\n\n# bloque_de_instrucciones_principal_1\n\nif condicion:\n    # bloque_de_instrucciones que\n    # se ejecuta si condicion es True\n\n# bloque_de_instrucciones_principal_2\n\n\n\n\n\n\n2.2.1 Ejemplo: Print trivial\ncount = 0\nwhile count &lt; 100:\n    print(\"I will lock my computer when I leave my desk\")\nprint(\"Uno\")\n\nif True:\n    print(\"Dos\")\n\nif False:\n    print(\"Tres\")\n\nprint(\"Cuatro\")\n\n\nOutput\n\nUno\nDos\nCuatro\n\n\n\n\n2.2.2 Ejemplo: Warning\nprint(\"Escriba un número:\")\na = int(input())\n\nif a &lt; 0:\n    print(f\"ATENCIÓN: El número {a} es negativo\")\n\nprint(f\"El número es {a}\")\nEscriba un número:\n5\nEl número es 5\nEscriba un número:\n-5\nATENCIÓN: El número -5 es negativo\nEl número es -5\n\n\n\n2.2.3 Ejemplo: Asignación condicional\nprint(\"Escriba un número:\")\na = int(input())\n\nif a &lt; 0:\n    a = 0\n\nprint(f\"El número es {a}\")\nEscriba un número:\n5\nEl número es 5\nEscriba un número:\n-5\nEl número es 0\n\n\n\n2.2.4 Ejemplo: Bloques de múltiples instrucciones\n\nprint(\"Escriba un número:\")\na = int(input())\n\nif a &lt; 0:\n    a = 0\n    print(\"El número es negativo\")\n    print(\"Se ha cambiado a 0\")\n\nprint(f\"El número es {a}\")\nEscriba un número:\n5\nEl número es 5\nEscriba un número:\n-5\nEl número es 0\nSe ha cambiado a 0\nEl número es 0\n\n\n\n\n2.3 Compocisión condicional: if-else\n\n\n\nA veces es necesario ejecutar un bloque de instrucciones si la condición es verdadera y otro bloque si es falsa.\nLa estructura if-else permite tomar decisiones en función de una condición.\n\nSi condición es verdadera, ejecuta el primer bloque.\nSi condición es falsa, ejecuta el segundo bloque.\nNUNCA se ejecutan ambos bloques.\n\n\n# bloque_de_instrucciones_principal_1\n\nif condicion:\n    # bloque_de_instrucciones_1\n    # se ejecuta si condicion es True\nelse:\n    # bloque_de_instrucciones_2\n    # se ejecuta si condicion es False\n\n#bloque_de_instrucciones_principal_2\n\n\n\n\n\n\n2.3.1 Ejemplo: Print trivial\nprint(\"Uno\")\n\nif False:\n    print(\"Dos\")\nelse:\n    print(\"Tres\")\n\nprint(\"Cuatro\")\n\n\nOutput\n\nUno\nTres\nCuatro\n\n\n\n\n2.3.2 Ejemplo: Números pares e impares\nprint(\"Escriba un número:\")\nnumero = int(input())\n\nif numero % 2 == 0:\n    print(f\"El número {numero} es par\")\nelse:\n    print(f\"El número {numero} es impar\")\nEscriba un número:\n4\nEl número 4 es par\nEscriba un número:\n5\nEl número 4 es impar\n\n\n\n2.3.3 Ejemplo: División por cero\nprint(\"Escriba un número:\")\na = int(input())\n\nprint(\"Escriba otro número:\")\nb = int(input())\n\nif b == 0:\n    print(\"No se puede dividir por cero!\")\nelse:\n    print(f\"{a} / {b} = {a / b}\")\nEscriba un número:\n4\nEscriba otro número:\n2\n4 / 2 = 2\nEscriba un número:\n4\nEscriba otro número:\n0\nNo se puede dividir por cero!\n\n\n\n\n2.4 Composición condicional: if-elif-else\n\n\n\nA veces es necesario evaluar múltiples condiciones.\nLa estructura if-elif-else permite encadenar decisiones en función de varias condiciones.\nLa sección else no es obligatoria, pero será necesaria en la mayoría de problemas.\n\n# bloque_de_instrucciones_principal_1\n\nif condicion_1:\n    # bloque_de_instrucciones_1\n    # se ejecuta si condicion_1 es True\nelif condicion_2:\n    # bloque_de_instrucciones_2\n    # se ejecuta si condicion_2 es True (y condicion_1 fue False)\nelse:\n    # bloque_de_instrucciones_3\n    # se ejecuta si condicion_1 y condicion_2 son False\n\n#bloque_de_instrucciones_principal_2\n\n\n\n\n\n\n2.4.1 Ejemplo: Print trivial\nprint(\"Uno\")\n\nif True:\n    print(\"Dos\")\nelif True:\n    print(\"Tres\")\nelse:\n    print(\"Cuatro\")\n\nprint(\"Cinco\")\n\n\nOutput\n\nUno\nDos\nCinco\n\n\n\n\n2.4.2 Ejemplo: Ecuación de segundo grado\n\n\nimport math\n\nprint(\"Escriba el coeficiente a:\")\na = float(input())\n\nprint(\"Escriba el coeficiente b:\")\nb = float(input())\n\nprint(\"Escriba el coeficiente c:\")\nc = float(input())\n\ndiscriminante = b ** 2 - 4 * a * c\n\nif discriminante &gt; 0:\n    x1 = (-b + math.sqrt(discriminante)) / (2 * a)\n    x2 = (-b - math.sqrt(discriminante)) / (2 * a)\n    print(f\"x1 = {x1}, x2 = {x2}\")\nelif discriminante == 0:\n    x = -b / (2 * a)\n    print(f\"x = {x}\")\nelse:\n    print(\"No reales\")\n\n\\[\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n\\]\nEscriba el coeficiente a:\n1\nEscriba el coeficiente b:\n-3\nEscriba el coeficiente c:\n2\nx1 = 2.0, x2 = 1.0\n\n\n\n\n\n\n2.5 Anidado de condicionales\n\nLlamamos anidado (nesting) a la composición de estructuras dentro de otras.\nPara definir un bucle, utilizamos la indentación.\n\nDistintos niveles de indentación indican distintos niveles de anidamiento.\n\n\nif condicion_1:\n    # Se ejecuta si condicion_1 es True\n    if condicion_2:\n        # Se ejecuta si condicion_1 y condicion_2 son True\n    else:\n        # Se ejecuta si condicion_1 es True y condicion_2 es False\n# Se ejecuta siempre\n\n\n2.5.1 Estructuras análogas: anidado vs and\n\nPara combinar dos expresiones no siempre es necesario recurir al anidamiento\nRecuerda que conoces los operadores lógicos and, or y not\n\n\n\nif condicion_1:\n    if condicion_2:\n        # Se ejecuta si:\n        # condicion_1 y condicion_2 son True\n# Se ejecuta siempre\n\nif condicion_1 and condicion_2:\n        # Se ejecuta si:\n        # condicion_1 y condicion_2 son True\n# Se ejecuta siempre\n\n\n\n\n\n2.5.2 Estructuras análogas: if-elif-else vs if-else\n\nLa estructura if-elif-else puede replicarse con anidando if-else\n\n\n\nif condicion_1:\n    # bloque_de_instrucciones_1\nelif condicion_2:\n    # bloque_de_instrucciones_2\nelse:\n    # bloque_de_instrucciones_3\n\nif condicion_1:\n    # bloque_de_instrucciones_1\nelse:\n    if condicion_2:\n        # bloque_de_instrucciones_2\n    else:\n        # bloque_de_instrucciones_3\n\n\n\n\n\n2.5.3 Ejemplo:\n\n\n\n2.5.4 Ejemplo: Ecuación de segundo grado (anidado)\nimport math\n\nprint(\"Escriba el coeficiente a:\")\na = float(input())\n\nprint(\"Escriba el coeficiente b:\")\nb = float(input())\n\nprint(\"Escriba el coeficiente c:\")\nc = float(input())\n\ndiscriminante = b ** 2 - 4 * a * c\n\nif discriminante &gt; 0:\n    x1 = (-b + math.sqrt(discriminante)) / (2 * a)\n    x2 = (-b - math.sqrt(discriminante)) / (2 * a)\n    print(f\"x1 = {x1}, x2 = {x2}\")\nelse:\n    if discriminante == 0:\n        x = -b / (2 * a)\n        print(f\"x = {x}\")\n    else:\n        print(\"No reales\")\nNota: Este ejemplo sirve para ilustrar el anidamiento. En la práctica, es preferible utilizar if-elif-else."
  },
  {
    "objectID": "src/01_teoria/03_composicion/301_composicion_condicional.html#usos-avanzados-de-la-composición-condicional",
    "href": "src/01_teoria/03_composicion/301_composicion_condicional.html#usos-avanzados-de-la-composición-condicional",
    "title": "Teoría 301",
    "section": "3 Usos avanzados de la composición condicional",
    "text": "3 Usos avanzados de la composición condicional\n\n\n3.1 Interacción conditional\n\nRecuerda que la interacción con el usuario se realiza también mediante instrucciones.\nEstas instrucciones pueden estar dentro de un bloque condicional.\n\n\n\nprint(\"Introduzce tu edad:\")\nedad = int(input())\n\nif edad &lt; 18:\n    print(\"¿Autorización paterna? (s/n)\")\n    res = input()\n    if res == \"s\":\n        print(\"Adelante\")  # Código repetido\n    else:\n        print(\"Lo siento, no puedes pasar\")\nelse:\n    print(\"Adelante\")  # Código repetido\n\nIntroduzce tu edad:\n21\nAdelante\nIntroduzce tu edad:\n15\n¿Autorización paterna? (s/n)\ns\nAdelante\n\n\n\n\n3.1.1 Alternativas al ejercicio anterior\n\n\nprint(\"Introduzce tu edad:\")\nedad = int(input())\n\n\nif edad &lt; 18:\n    print(\"¿Autorización paterna? (s/n)\")\n    res = input()\n    if res == \"s\":\n        permiso = True\n    else:\n        permiso = False\nelse:\n    permiso = True\n\nif permiso:\n    print(\"Adelante\")\nelse:\n    print(\"Lo siento, no puedes pasar\")\nCuidado con definir siempre un valor para permiso.\n\nprint(\"Introduzce tu edad:\")\nedad = int(input())\n\npermiso = False\n\nif edad &lt; 18:\n    print(\"¿Autorización paterna? (s/n)\")\n    res = input()\n    if res == \"s\":\n        permiso = True\nelse:\n    permiso = True\n\nif permiso:\n    print(\"Adelante\")\nelse:\n    print(\"Lo siento, no puedes pasar\")\nNota: En este caso, permiso se asume inicialmente False."
  },
  {
    "objectID": "src/01_teoria/03_composicion/301_composicion_condicional.reveal.html#límites-de-la-composición-secuencial",
    "href": "src/01_teoria/03_composicion/301_composicion_condicional.reveal.html#límites-de-la-composición-secuencial",
    "title": "Teoría 301",
    "section": "Límites de la composición secuencial",
    "text": "Límites de la composición secuencial"
  },
  {
    "objectID": "src/01_teoria/03_composicion/301_composicion_condicional.reveal.html#composición-condicional",
    "href": "src/01_teoria/03_composicion/301_composicion_condicional.reveal.html#composición-condicional",
    "title": "Teoría 301",
    "section": "Composición condicional",
    "text": "Composición condicional"
  },
  {
    "objectID": "src/01_teoria/03_composicion/301_composicion_condicional.reveal.html#usos-avanzados-de-la-composición-condicional",
    "href": "src/01_teoria/03_composicion/301_composicion_condicional.reveal.html#usos-avanzados-de-la-composición-condicional",
    "title": "Teoría 301",
    "section": "Usos avanzados de la composición condicional",
    "text": "Usos avanzados de la composición condicional"
  },
  {
    "objectID": "src/01_teoria/03_composicion/303_composicion_iterativa_while_II.html",
    "href": "src/01_teoria/03_composicion/303_composicion_iterativa_while_II.html",
    "title": "Teoría 303",
    "section": "",
    "text": "Existe un patrón de problema común en el que nuestro programa ha de acumular un resultado de forma iterativa.\nEstas variables acumuladoras han siempre de ser inicializadas antes de comenzar la iteración.\n\nEj. accum = 0\n\nRecuerda que conoces los operadores de asignación aumentada.\n\nEj. accum += 1\n\nSegún el tipo de operación que vaya a recibir la variable acumuladora, deberemos inicializarla con un valor adecuado.\n\nEj. accum = 1 para multiplicaciones.\n\n\n\n\n\n\nEscribe un programa Python que solicite un número entero positivo n al usuario y calcule la suma de los primeros n números naturales.\n\nDeberemos recorrer los n primeros números naturales (incluyendo n).\nPara cada número, deberemos acumular la suma.\n\n\nIntroduce un número entero positivo:\n5\nLa suma de los primeros 5 números naturales es 15\n\nSolución\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nsuma = 0\n\ni = 1\nwhile i &lt;= n:\n    suma = suma + i\n    i += 1\n\nprint(f\"La suma de los primeros {n} números naturales es {suma}\")\n\nImplementación alternativa\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nsuma = 0\n\nwhile n &gt; 0:\n    suma = suma + n\n    n = n - 1\n\n# Ya no podemos saber cuantos números nos pidieron\n# print(f\"La suma de los primeros {n} números naturales es {suma}\")\nprint(f\"La suma es {suma}\")\n\n\n\n\n\nEscribe un programa Python que calcule la suma de todos los múltiplos de 3 o 5 menores que 1000.\n\nDeberemos recorrer los números menores que 1000.\nPara los números que sean múltiplos de 3 o 5, deberemos acumular la suma.\n\n\nLa suma de los múltiplos de 3 o 5 menores que 1000 es 233168\n\nSolución\nsuma = 0\n\ni = 0\nwhile i &lt; 1000:\n    if i % 3 == 0 or i % 5 == 0:\n        suma = suma + i\n    i += 1\n\nprint(f\"La suma de los múltiplos de 3 o 5 menores que 1000 es {suma}\")\n\n\n\n\n\nEscribe un programa Python que solicite un número entero positivo n al usuario y calcule el factorial de n.\n\nDeberemos recorrer los números desde n hasta 1.\nPara cada número, deberemos acumular el producto.\n\n\nIntroduce un número entero positivo:\n5\nEl factorial de 5 es 120\n\nEncuentra los errores\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nfactorial = 0\n\ni = 0\nwhile i &lt; n:\n    print(f\"i: {i}, factorial: {factorial}\")\n    factorial *= i\n    i += 1\n\nprint(f\"El factorial de {n} es {factorial}\")\n\nEncuentra los errores\n\nErrores:\n\ni=0 debería ser i=1\nfactorial=0 debería ser factorial=1\ni&lt;n debería ser i&lt;=n\n\n\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nfactorial = 1\n\ni = 1\nwhile i &lt;= n:\n    print(f\"i: {i}, factorial: {factorial}\")\n    factorial *= i\n    i += 1\n\nprint(f\"El factorial de {n} es {factorial}\")\n\n\n\n\n\n\nExiste un patrón de problema común en el que nuestro programa ha de explorar una secuencia de tamaño indeterminado de elementos.\nEn este tipo de problemas será habitual:\n\nDeterminar una condición de parada.\nImplementar un bucle que se repita mientras la condición de parada no se cumpla.\n\n\n\n\n\n\nEscribe un programa Python que solicite al usuario números enteros (positivos o negativos) y calcule la suma de todos los números introducidos.\n\nDeberemos recorrer los números introducidos por el usuario.\nPara cada número, deberemos acumular la suma.\nDeberemos parar cuando el usuario introduzca un número igual a 0.\n\n\nIntroduce un número entero:\n5\nIntroduce un número entero:\n-3\nIntroduce un número entero:\n2\nIntroduce un número entero:\n0\nLa suma de los números introducidos es 4\n\nSolución\nsuma = 0  # Acumulador\n\ncontinuar = True\n\nwhile continuar:\n    print(\"Introduce un número entero:\")\n    n = int(input())\n\n    if n == 0:\n        continuar = False\n    else:\n        suma = suma + n\n\nprint(f\"La suma de los números introducidos es {suma}\")\n\nImplementación alternativa\nsuma = 0  # Acumulador\n\nprint(\"Introduce un número entero:\")\nn = int(input())\n\nwhile n != 0:\n    suma = suma + n\n\n    print(\"Introduce un número entero:\")\n    n = int(input())\n\nprint(f\"La suma de los números introducidos es {suma}\")\n\n\n\n\n\n\nExiste un patrón de problema común en el que nuestro programa ha de buscar un elemento en una secuencia.\nEn este tipo de problemas será habitual:\n\nDeterminar un valor inicial para el elemento buscado.\nImplementar un bucle que se repita mientras la condición de parada no se cumpla.\nComparar el elemento actual con el elemento buscado.\n\n\n\n\n\n\nEscribe un programa Python que simule un juego en el que el usuario ha de adivinar un número secreto.\n\nEl número secreto es 42.\n\n\nIntroduce un número:\n5\nIntroduce un número:\n23\nIntroduce un número:\n42\n¡Encontrado!\n\nSolución\nNUMERO_SECRETO = 42\n\nencontrado = False\n\nwhile not encontrado:\n    print(\"Introduce un número:\")\n    n = int(input())\n\n    if n == NUMERO_SECRETO:\n        encontrado = True\n\nif encontrado:\n    print(\"¡Encontrado!\")\n\n\n\n\n\nEscribe un programa Python que simule un juego en el que el usuario ha de adivinar un número secreto.\n\nEl número secreto es 42.\nEl usuario puede rendirse introduciendo el número 0.\n\n\nIntroduce un número:\n5\nIntroduce un número:\n0\n¡Rendido!\n\nSolución\nNUMERO_SECRETO = 42\n\nencontrado = False\nn = -1  # Cualquier valor que no sea 0\n\nwhile not encontrado and n != 0:\n    print(\"Introduce un número:\")\n    n = int(input())\n\n    if n == NUMERO_SECRETO:\n        encontrado = True\n\nif encontrado:\n    print(\"¡Encontrado!\")\nelse:\n    print(\"¡Rendido!\")\n\n\n\n\n\n\nLos errores off-by-one son errores comunes en los que se produce un desfase de una unidad.\nEstos errores suelen producirse en bucles y en índices (lo veremos más adelante).\nLos elementos problemáticos suelen ser:\n\nEl valor de inicio de una variable\nLa expresión booleana de comparación (&lt; en lugar de &lt;=)\nLa instrucción de incremento/decremento\n\n\n\n\n\n\nEscribe un programa Python que solicite un número entero positivo n al usuario y calcule la suma de los primeros n números naturales.\n\nEncuentra el error\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nsuma = 0\n\ni = 1\nwhile i &lt; n:\n    suma = suma + i\n    i += 1\n\nprint(f\"La suma de los primeros {n} números naturales es {suma}\")\n\nEncuentra el error\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nsuma = 0\n\ni = 1\nwhile i &lt;= n:\n    i += 1\n    suma = suma + i\n\nprint(f\"La suma de los primeros {n} números naturales es {suma}\")"
  },
  {
    "objectID": "src/01_teoria/03_composicion/303_composicion_iterativa_while_II.html#composición-iterativa-ii",
    "href": "src/01_teoria/03_composicion/303_composicion_iterativa_while_II.html#composición-iterativa-ii",
    "title": "Teoría 303",
    "section": "",
    "text": "Existe un patrón de problema común en el que nuestro programa ha de acumular un resultado de forma iterativa.\nEstas variables acumuladoras han siempre de ser inicializadas antes de comenzar la iteración.\n\nEj. accum = 0\n\nRecuerda que conoces los operadores de asignación aumentada.\n\nEj. accum += 1\n\nSegún el tipo de operación que vaya a recibir la variable acumuladora, deberemos inicializarla con un valor adecuado.\n\nEj. accum = 1 para multiplicaciones.\n\n\n\n\n\n\nEscribe un programa Python que solicite un número entero positivo n al usuario y calcule la suma de los primeros n números naturales.\n\nDeberemos recorrer los n primeros números naturales (incluyendo n).\nPara cada número, deberemos acumular la suma.\n\n\nIntroduce un número entero positivo:\n5\nLa suma de los primeros 5 números naturales es 15\n\nSolución\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nsuma = 0\n\ni = 1\nwhile i &lt;= n:\n    suma = suma + i\n    i += 1\n\nprint(f\"La suma de los primeros {n} números naturales es {suma}\")\n\nImplementación alternativa\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nsuma = 0\n\nwhile n &gt; 0:\n    suma = suma + n\n    n = n - 1\n\n# Ya no podemos saber cuantos números nos pidieron\n# print(f\"La suma de los primeros {n} números naturales es {suma}\")\nprint(f\"La suma es {suma}\")\n\n\n\n\n\nEscribe un programa Python que calcule la suma de todos los múltiplos de 3 o 5 menores que 1000.\n\nDeberemos recorrer los números menores que 1000.\nPara los números que sean múltiplos de 3 o 5, deberemos acumular la suma.\n\n\nLa suma de los múltiplos de 3 o 5 menores que 1000 es 233168\n\nSolución\nsuma = 0\n\ni = 0\nwhile i &lt; 1000:\n    if i % 3 == 0 or i % 5 == 0:\n        suma = suma + i\n    i += 1\n\nprint(f\"La suma de los múltiplos de 3 o 5 menores que 1000 es {suma}\")\n\n\n\n\n\nEscribe un programa Python que solicite un número entero positivo n al usuario y calcule el factorial de n.\n\nDeberemos recorrer los números desde n hasta 1.\nPara cada número, deberemos acumular el producto.\n\n\nIntroduce un número entero positivo:\n5\nEl factorial de 5 es 120\n\nEncuentra los errores\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nfactorial = 0\n\ni = 0\nwhile i &lt; n:\n    print(f\"i: {i}, factorial: {factorial}\")\n    factorial *= i\n    i += 1\n\nprint(f\"El factorial de {n} es {factorial}\")\n\nEncuentra los errores\n\nErrores:\n\ni=0 debería ser i=1\nfactorial=0 debería ser factorial=1\ni&lt;n debería ser i&lt;=n\n\n\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nfactorial = 1\n\ni = 1\nwhile i &lt;= n:\n    print(f\"i: {i}, factorial: {factorial}\")\n    factorial *= i\n    i += 1\n\nprint(f\"El factorial de {n} es {factorial}\")\n\n\n\n\n\n\nExiste un patrón de problema común en el que nuestro programa ha de explorar una secuencia de tamaño indeterminado de elementos.\nEn este tipo de problemas será habitual:\n\nDeterminar una condición de parada.\nImplementar un bucle que se repita mientras la condición de parada no se cumpla.\n\n\n\n\n\n\nEscribe un programa Python que solicite al usuario números enteros (positivos o negativos) y calcule la suma de todos los números introducidos.\n\nDeberemos recorrer los números introducidos por el usuario.\nPara cada número, deberemos acumular la suma.\nDeberemos parar cuando el usuario introduzca un número igual a 0.\n\n\nIntroduce un número entero:\n5\nIntroduce un número entero:\n-3\nIntroduce un número entero:\n2\nIntroduce un número entero:\n0\nLa suma de los números introducidos es 4\n\nSolución\nsuma = 0  # Acumulador\n\ncontinuar = True\n\nwhile continuar:\n    print(\"Introduce un número entero:\")\n    n = int(input())\n\n    if n == 0:\n        continuar = False\n    else:\n        suma = suma + n\n\nprint(f\"La suma de los números introducidos es {suma}\")\n\nImplementación alternativa\nsuma = 0  # Acumulador\n\nprint(\"Introduce un número entero:\")\nn = int(input())\n\nwhile n != 0:\n    suma = suma + n\n\n    print(\"Introduce un número entero:\")\n    n = int(input())\n\nprint(f\"La suma de los números introducidos es {suma}\")\n\n\n\n\n\n\nExiste un patrón de problema común en el que nuestro programa ha de buscar un elemento en una secuencia.\nEn este tipo de problemas será habitual:\n\nDeterminar un valor inicial para el elemento buscado.\nImplementar un bucle que se repita mientras la condición de parada no se cumpla.\nComparar el elemento actual con el elemento buscado.\n\n\n\n\n\n\nEscribe un programa Python que simule un juego en el que el usuario ha de adivinar un número secreto.\n\nEl número secreto es 42.\n\n\nIntroduce un número:\n5\nIntroduce un número:\n23\nIntroduce un número:\n42\n¡Encontrado!\n\nSolución\nNUMERO_SECRETO = 42\n\nencontrado = False\n\nwhile not encontrado:\n    print(\"Introduce un número:\")\n    n = int(input())\n\n    if n == NUMERO_SECRETO:\n        encontrado = True\n\nif encontrado:\n    print(\"¡Encontrado!\")\n\n\n\n\n\nEscribe un programa Python que simule un juego en el que el usuario ha de adivinar un número secreto.\n\nEl número secreto es 42.\nEl usuario puede rendirse introduciendo el número 0.\n\n\nIntroduce un número:\n5\nIntroduce un número:\n0\n¡Rendido!\n\nSolución\nNUMERO_SECRETO = 42\n\nencontrado = False\nn = -1  # Cualquier valor que no sea 0\n\nwhile not encontrado and n != 0:\n    print(\"Introduce un número:\")\n    n = int(input())\n\n    if n == NUMERO_SECRETO:\n        encontrado = True\n\nif encontrado:\n    print(\"¡Encontrado!\")\nelse:\n    print(\"¡Rendido!\")\n\n\n\n\n\n\nLos errores off-by-one son errores comunes en los que se produce un desfase de una unidad.\nEstos errores suelen producirse en bucles y en índices (lo veremos más adelante).\nLos elementos problemáticos suelen ser:\n\nEl valor de inicio de una variable\nLa expresión booleana de comparación (&lt; en lugar de &lt;=)\nLa instrucción de incremento/decremento\n\n\n\n\n\n\nEscribe un programa Python que solicite un número entero positivo n al usuario y calcule la suma de los primeros n números naturales.\n\nEncuentra el error\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nsuma = 0\n\ni = 1\nwhile i &lt; n:\n    suma = suma + i\n    i += 1\n\nprint(f\"La suma de los primeros {n} números naturales es {suma}\")\n\nEncuentra el error\nprint(\"Introduce un número entero positivo:\")\nn = int(input())\n\nsuma = 0\n\ni = 1\nwhile i &lt;= n:\n    i += 1\n    suma = suma + i\n\nprint(f\"La suma de los primeros {n} números naturales es {suma}\")"
  },
  {
    "objectID": "src/01_teoria/03_composicion/303_composicion_iterativa_while_II.reveal.html#composición-iterativa-ii",
    "href": "src/01_teoria/03_composicion/303_composicion_iterativa_while_II.reveal.html#composición-iterativa-ii",
    "title": "Teoría 303",
    "section": "Composición Iterativa II",
    "text": "Composición Iterativa II"
  },
  {
    "objectID": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.html",
    "href": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.html",
    "title": "Teoría 305",
    "section": "",
    "text": "En esta sesión vamos a profundizar en el uso de bucles for aplicados a múltiples dominios.\nEsta no es una cobertura exhaustiva de todos los escenarios donde son aplicables.\n\n\n\n\n\nLos patrones iterativos son muy útiles para generar representaciones gráficas.\n\nLa repetición de un elemento en un patrón regular.\n\nPor ejemplo, dibujar una cuadrícula de 4x10 asteriscos (*).\n\nDibujar 10 asteriscos en una fila.\nRepetir 4 veces.\n\nEn esta sección, además, veremos formas avanzadas de pintar por pantalla.\n\n\n\n\nEscribe un programa Python que dibuje una cuadrícula de 4x10 asteriscos.\n**********\n**********\n**********\n**********\n\n\n\n\n\n\nPara resolverlo tendrás que utilizar print(\"*\", end=\"\") para evitar saltos de línea.\n\n\n\n\nSolución:\nfor i in range(4):\n    for j in range(10):\n        print(\"*\", end=\"\")\n    print()\n\n\n\n\n\n\nObserva el uso de print(t, end=\"\") para evitar saltos de línea.\n\nend=\"\" indica que no se añada un salto de línea al final de la impresión.\nprint() es equivalente a print(\"\").\n\n\n\n\n\n\n\n\nEscribe un programa Python que imprima los números del 1 al 10 multiplicados entre sí.\n   1   2   3   4   5   6   7   8   9  10\n   2   4   6   8  10  12  14  16  18  20\n   3   6   9  12  15  18  21  24  27  30\n   4   8  12  16  20  24  28  32  36  40\n   5  10  15  20  25  30  35  40  45  50\n   6  12  18  24  30  36  42  48  54  60\n   7  14  21  28  35  42  49  56  63  70\n   8  16  24  32  40  48  56  64  72  80\n   9  18  27  36  45  54  63  72  81  90\n  10  20  30  40  50  60  70  80  90 100\n\n\n\n\n\n\nPara alinear los números, puedes usar f\"{producto:4}\".\n\n\n\n\nSolución:\nfor i in range(1, 11):\n    for j in range(1, 11):\n        producto = i * j\n        print(f\"{producto:4}\", end=\"\")\n    print()\n\n\n\n\n\n\nObserva el uso de f\"{producto:4}\" para alinear los números.\n\nEn las f-strings, :4 indica que el número se imprima en un espacio de 4 caracteres.\nSi el número tiene menos de 4 dígitos, se rellena con espacios a la izquierda.\nSi el número tiene más de 4 dígitos, se imprime sin cambios.\nEsto permite alinear los números en columnas.\n\n\n\n\n\n\n\n\nEscribe un programa Python que imprima una plantilla de un calendario de un mes.\n  L   M   X   J   V   S   D\n  1   2   3   4   5   6   7 \n  8   9  10  11  12  13  14 \n 15  16  17  18  19  20  21 \n 22  23  24  25  26  27  28 \n 29  30  31 \n\nSolución:\nprint(\"  L   M   X   J   V   S   D\")\nfor i in range(1, 31+1):\n    print(f\"{i:3}\", end=\" \")\n    if i % 7 == 0:\n        print()\n\n\n\n\n\n\nLa combinatoria es una rama de las matemáticas que estudia las posibles combinaciones de elementos.\nEn Python, podemos usar bucles for para generar todas las combinaciones posibles.\nPor ejemplo, generar todas las combinaciones de dos dados.\n\n\n\n\nPrograma Python que genera todas las combinaciones posibles de dos dados.\nfor i in range(1, 6+1):\n    for j in range(1, 6+1):\n        print(f\"{i} {j}\")\n\n\n\n\nEscribe un programa Python que genere todas las combinaciones de dos dados cuya suma sea 7.\n1 6\n2 5\n3 4\n4 3\n5 2\n6 1\n\nSolución:\nfor i in range(1, 6+1):\n    for j in range(1, 6+1):\n        if i + j == 7:\n            print(f\"{i} {j}\")"
  },
  {
    "objectID": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.html#uso-avanzado-de-los-bucles-for",
    "href": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.html#uso-avanzado-de-los-bucles-for",
    "title": "Teoría 305",
    "section": "",
    "text": "En esta sesión vamos a profundizar en el uso de bucles for aplicados a múltiples dominios.\nEsta no es una cobertura exhaustiva de todos los escenarios donde son aplicables.\n\n\n\n\n\nLos patrones iterativos son muy útiles para generar representaciones gráficas.\n\nLa repetición de un elemento en un patrón regular.\n\nPor ejemplo, dibujar una cuadrícula de 4x10 asteriscos (*).\n\nDibujar 10 asteriscos en una fila.\nRepetir 4 veces.\n\nEn esta sección, además, veremos formas avanzadas de pintar por pantalla.\n\n\n\n\nEscribe un programa Python que dibuje una cuadrícula de 4x10 asteriscos.\n**********\n**********\n**********\n**********\n\n\n\n\n\n\nPara resolverlo tendrás que utilizar print(\"*\", end=\"\") para evitar saltos de línea.\n\n\n\n\nSolución:\nfor i in range(4):\n    for j in range(10):\n        print(\"*\", end=\"\")\n    print()\n\n\n\n\n\n\nObserva el uso de print(t, end=\"\") para evitar saltos de línea.\n\nend=\"\" indica que no se añada un salto de línea al final de la impresión.\nprint() es equivalente a print(\"\").\n\n\n\n\n\n\n\n\nEscribe un programa Python que imprima los números del 1 al 10 multiplicados entre sí.\n   1   2   3   4   5   6   7   8   9  10\n   2   4   6   8  10  12  14  16  18  20\n   3   6   9  12  15  18  21  24  27  30\n   4   8  12  16  20  24  28  32  36  40\n   5  10  15  20  25  30  35  40  45  50\n   6  12  18  24  30  36  42  48  54  60\n   7  14  21  28  35  42  49  56  63  70\n   8  16  24  32  40  48  56  64  72  80\n   9  18  27  36  45  54  63  72  81  90\n  10  20  30  40  50  60  70  80  90 100\n\n\n\n\n\n\nPara alinear los números, puedes usar f\"{producto:4}\".\n\n\n\n\nSolución:\nfor i in range(1, 11):\n    for j in range(1, 11):\n        producto = i * j\n        print(f\"{producto:4}\", end=\"\")\n    print()\n\n\n\n\n\n\nObserva el uso de f\"{producto:4}\" para alinear los números.\n\nEn las f-strings, :4 indica que el número se imprima en un espacio de 4 caracteres.\nSi el número tiene menos de 4 dígitos, se rellena con espacios a la izquierda.\nSi el número tiene más de 4 dígitos, se imprime sin cambios.\nEsto permite alinear los números en columnas.\n\n\n\n\n\n\n\n\nEscribe un programa Python que imprima una plantilla de un calendario de un mes.\n  L   M   X   J   V   S   D\n  1   2   3   4   5   6   7 \n  8   9  10  11  12  13  14 \n 15  16  17  18  19  20  21 \n 22  23  24  25  26  27  28 \n 29  30  31 \n\nSolución:\nprint(\"  L   M   X   J   V   S   D\")\nfor i in range(1, 31+1):\n    print(f\"{i:3}\", end=\" \")\n    if i % 7 == 0:\n        print()\n\n\n\n\n\n\nLa combinatoria es una rama de las matemáticas que estudia las posibles combinaciones de elementos.\nEn Python, podemos usar bucles for para generar todas las combinaciones posibles.\nPor ejemplo, generar todas las combinaciones de dos dados.\n\n\n\n\nPrograma Python que genera todas las combinaciones posibles de dos dados.\nfor i in range(1, 6+1):\n    for j in range(1, 6+1):\n        print(f\"{i} {j}\")\n\n\n\n\nEscribe un programa Python que genere todas las combinaciones de dos dados cuya suma sea 7.\n1 6\n2 5\n3 4\n4 3\n5 2\n6 1\n\nSolución:\nfor i in range(1, 6+1):\n    for j in range(1, 6+1):\n        if i + j == 7:\n            print(f\"{i} {j}\")"
  },
  {
    "objectID": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.html#otros-usos-avanzados-de-los-bucles",
    "href": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.html#otros-usos-avanzados-de-los-bucles",
    "title": "Teoría 305",
    "section": "2 Otros usos avanzados de los bucles",
    "text": "2 Otros usos avanzados de los bucles\n\n\n2.1 Búsqueda II\n\nEn la sesión de Composición Iterativa II, vimos ejemplos sencillos de búsqueda (Adivina un número).\nExisten ejemplos más complejos de búsqueda que requieren de criterios más sofisticados.\n\n\n\n2.1.1 Ejercicio: Comprueba si un número es primo\nEscribe un programa Python que compruebe si un número es primo.\n\nFormulado de esta manera, no parece un problema de búsqueda. Sin embargo, podemos decir que un número NO es primo si le ENCONTRAMOS un divisor.\n\nIntroduce un número entero:\n7\n7 es primo\nIntroduce un número entero:\n8\n8 no es primo\n\nSolución:\nprint(\"Introduce un número entero:\")\ncandidato = int(input())\n\nes_primo = True\ni = 2\nwhile es_primo and i &lt; candidato:\n    if candidato % i == 0:\n        es_primo = False\n    i += 1\n\nif es_primo:\n    print(f\"{candidato} es primo\")\nelse:\n    print(f\"{candidato} no es primo\")\n\n\n\n\n\n\nNo utilizamos un bucle for porque no sabemos cuántas iteraciones necesitaremos.\n\n\n\n\n\n\n2.1.2 Ejercicio: Encontrar el primer número primo mayor que N\nEscribe un programa Python que encuentre el primer número primo mayor que un número N dado.\nIntroduce un número entero:\n10\nEl primer número primo mayor que 10 es 11\nIntroduce un número entero:\n20\nEl primer número primo mayor que 20 es 23\n\nSolución: (sin usar for ni break)\nprint(\"Introduce un número entero:\")\nn = int(input())\n\ncandidato = n + 1\nencontrado = False\nwhile not encontrado:\n    # Del ejercicio anterior\n    es_primo = True\n    i = 2\n    while es_primo and i &lt; candidato:\n        if candidato % i == 0:\n            es_primo = False\n        i += 1\n    # Hasta aquí\n\n    if es_primo:\n        encontrado = True\n    else:\n        candidato += 1\n\nprint(f\"El primer número primo mayor que {n} es {candidato}\")\n\n\n\n\n2.2 Lo que está por venir\n\nPuede parecer que los bucles for son una herramienta simple y limitada.\nEl verdadero potencial de los bucles for se desbloquea cuando se combinan con funciones y estructuras de datos.\nA lo largo del curso, volveremos a retomar y profundizar en los bucles for y while."
  },
  {
    "objectID": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.reveal.html#uso-avanzado-de-los-bucles-for",
    "href": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.reveal.html#uso-avanzado-de-los-bucles-for",
    "title": "Teoría 305",
    "section": "Uso avanzado de los bucles for",
    "text": "Uso avanzado de los bucles for"
  },
  {
    "objectID": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.reveal.html#otros-usos-avanzados-de-los-bucles",
    "href": "src/01_teoria/03_composicion/305_composicion_iterativa_for_II.reveal.html#otros-usos-avanzados-de-los-bucles",
    "title": "Teoría 305",
    "section": "Otros usos avanzados de los bucles",
    "text": "Otros usos avanzados de los bucles"
  },
  {
    "objectID": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.html",
    "href": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.html",
    "title": "Teoría 401",
    "section": "",
    "text": "Los ejercicios abordados hasta ahora han sido específicamente diseñados para ser senillos y fáciles de entender.\nEn la práctica, los programas suelen ser (mucho) más complejos.\nPara abordar esta complejidad, debemos proveernos de métodos y estrategias que nos faciliten el trabajo.\nEn proyectos grandes, es fundamental:\n\nLegibilidad.\nMantenibilidad.\nReutilización.\nTestabilidad.\n\n\n\n\n\n\n\nUna de las estrategias más efectivas para abordar la complejidad es la modularización.\nConsiste en dividir el problema en partes más pequeñas y manejables.\n\nCada parte se convierte en un módulo independiente.\nCada módulo se encarga de una tarea específica.\nLos módulos se comunican o coordinan para resolver el problema global.\n\n\n\n\n\n\nEscribe un Programa Python que implemente una calculadora de números complejos con las siguientes operaciones: suma, resta, multiplicación y división.\nEl programa debe:\n\nPedir al usuario que introduzca dos números complejos.\nPedir al usuario que introduzca la operación a realizar.\nCalcular el resultado de la operación.\nMostrar el resultado con la forma: {real} + {imag} i.\n\nSe han impartido todos los conocimientos mínimos para resolver este problema.\n\nPero no para abordarlo de forma modular.\n\n\n\n\n\n\n\n\n\n\nMódulos del programa:\n\nEntrada: se encarga de pedir al usuario los números y la operación.\n\nEntrada de números: pide al usuario los números.\nEntrada de operación: pide al usuario la operación.\n\nCálculo: se encarga de realizar la operación.\nSalida: se encarga de mostrar el resultado.\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara coordinarse y funcionar adecuada, los módulos deben comunicarse.\nLa forma de comunicación entre módulos más común es: compartir información (variables).\n\nUna información será producida por un módulo,\npara luego ser consumida por otro(s) módulo(s)."
  },
  {
    "objectID": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.html#modularización",
    "href": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.html#modularización",
    "title": "Teoría 401",
    "section": "",
    "text": "Los ejercicios abordados hasta ahora han sido específicamente diseñados para ser senillos y fáciles de entender.\nEn la práctica, los programas suelen ser (mucho) más complejos.\nPara abordar esta complejidad, debemos proveernos de métodos y estrategias que nos faciliten el trabajo.\nEn proyectos grandes, es fundamental:\n\nLegibilidad.\nMantenibilidad.\nReutilización.\nTestabilidad.\n\n\n\n\n\n\n\nUna de las estrategias más efectivas para abordar la complejidad es la modularización.\nConsiste en dividir el problema en partes más pequeñas y manejables.\n\nCada parte se convierte en un módulo independiente.\nCada módulo se encarga de una tarea específica.\nLos módulos se comunican o coordinan para resolver el problema global.\n\n\n\n\n\n\nEscribe un Programa Python que implemente una calculadora de números complejos con las siguientes operaciones: suma, resta, multiplicación y división.\nEl programa debe:\n\nPedir al usuario que introduzca dos números complejos.\nPedir al usuario que introduzca la operación a realizar.\nCalcular el resultado de la operación.\nMostrar el resultado con la forma: {real} + {imag} i.\n\nSe han impartido todos los conocimientos mínimos para resolver este problema.\n\nPero no para abordarlo de forma modular.\n\n\n\n\n\n\n\n\n\n\nMódulos del programa:\n\nEntrada: se encarga de pedir al usuario los números y la operación.\n\nEntrada de números: pide al usuario los números.\nEntrada de operación: pide al usuario la operación.\n\nCálculo: se encarga de realizar la operación.\nSalida: se encarga de mostrar el resultado.\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara coordinarse y funcionar adecuada, los módulos deben comunicarse.\nLa forma de comunicación entre módulos más común es: compartir información (variables).\n\nUna información será producida por un módulo,\npara luego ser consumida por otro(s) módulo(s)."
  },
  {
    "objectID": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.html#funciones",
    "href": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.html#funciones",
    "title": "Teoría 401",
    "section": "2 Funciones",
    "text": "2 Funciones\n\n\n2.1 Funciones\n\n\n\nLa forma de modularizar en Python es a través de funciones.\nLas funciones son bloques de código que realizan una tarea específica.\nSe componen de:\n\nNombre: identificador único.\nArgumentos: valores de entrada.\nCuerpo: código que realiza la tarea.\nValor de retorno [opcional]: resultado de la tarea.\n\nSe definen usando la palabra reservada def.\n\n\ndef nombre_funcion(argumentos):\n    # Cuerpo de la función\n\n\n\n\n2.1.1 Ejemplo: Definición de la función “saluda”\ndef saluda():\n    print(\"¡Hola, mundo!\")\n\nEsta función se encargaría de mostrar por pantalla el mensaje ¡Hola, mundo!.\nRecuerda la importancia de la indentación.\nEjecutar el código anterior no mostrará nada por pantalla.\n\nLa hemos definido, pero no la hemos ejecutado.\n\n\n\n\n\n\n2.2 Invocación de una función\n\nPara ejecutar una función, debemos invocarla.\nUna función se invoca escribiendo su nombre seguido de sus argumentos entre paréntesis.\n\nSi no tiene argumentos, los paréntesis se mantienen vacíos.\n\nAl igual que con las variables:\n\nLas funciónes deben ser definidas antes de ser invocadas.\n\nPor ello el orden de un programa será: definir funciones y luego programa principal.\n\ndef funcion1():\n    # Cuerpo de la función 1\n\ndef funcion2():\n    # Cuerpo de la función 2\n\n# Cuerpo del programa principal\n\n\n2.2.1 Ejemplo: Invocación de la función “saluda”\ndef saluda():\n    print(\"Hola, mundo!\")\n\nsaluda()\nHola, mundo!\n\nAl invocar la función saluda, se mostrará por pantalla el mensaje ¡Hola, mundo!.\nRecuerda: la función debe ser definida antes de ser invocada.\n\n\n\n\n2.2.2 Ejemplo: Función “castigo”\ndef castigo():\n    for i in range(0, 100):\n        print(\"No llevaré el movil encima el día del examen.\")\n\ncastigo()\nNo llevaré el movil encima el día del examen.\nNo llevaré el movil encima el día del examen.\nNo llevaré el movil encima el día del examen.\n. . .\n\n\n\n\n2.3 Orden de ejecución de una función\n\nSabemos que es fundamental saber leer/predecir el orden de ejecución de cualquier programa para poder entenderlo.\n\nDel mismo modo que hemos aprendido a leer bucles y condicionales, debemos aprender a leer funciones.\n\n\n\n\n2.3.1 Ejercicio: Orden de ejecución\nDetermina la salida por pantalla del siguiente código\ndef funcion1():\n    print(\"Función 1\")\n\ndef funcion2():\n    funcion1()\n    print(\"Función 2\")\n\nprint(\"Global 1\")\nfuncion1()\nprint(\"Global 2\")\nfuncion2()\nprint(\"Global 3\")\n\n\nSolución\n\nGlobal 1\nFunción 1\nGlobal 2\nFunción 1\nFunción 2\nGlobal 3\n\n\n\n\n\n2.4 Scope\n\nUno de los principios clave de los módulos es la independencia (desacoplado) del programa principal.\n\nUn módulo que no depende de otros módulos es más fácil de entender y mantener.\n\nSi los módulos comparten de forma descontrolada todas las variables entre sí:\n\nCorren el riesgo de interferir (propenso a errores).\nSe vuelve dificil entender y mantener el código.\n\n¿De dónde viene el valor de esta variable?\n\n\n\n\n\nUna variable definida dentro de una función se denomina local a esa función:\n\nSolo es visible y accesible dentro de la función.\n\nUna variable definida en el programa principal se denomina global:\n\nSólo debería visible ni accesible para el programa principal, y no para las funciones.\nSin embargo, Python permite acceder a las variables globales desde las funciones.\n\n\ndef mi_funcion():\n    variable_local = 42\n\nvariable_global = 42\n\n\n\nEste código fallará:\ndef funcion():\n    variable = 42 # Variable local\n    print(variable) # OK\n\nfuncion()\nprint(variable) # Error: variable no definida\n\nPero este no fallará:\ndef funcion():\n    print(variable) # OK\n\nvariable = 42 # Variable global\nfuncion()\nprint(variable) # OK\n\n\nUna forma de prevenir utilizar sin querer las variables del programa principal es meter todo el programa principal en una funcion:\n\nEsta no es una práctica obligatoria (salvo que se indique así) pero es una buena práctica preventiva.\n\ndef funcion():\n    print(variable) # Error: variable no definida\n\ndef main():\n    funcion()\n    variable = 42 # Variable local\n    print(variable) \n\nmain() # Esta es la UNICA instrucción global\n\n\n\n2.5 Argumentos\n\nHemos concluido que las funciones no deben tener acceso descontrolado a todas las variables,\nCuando necesitemos comunicar información a una función, utilizaremos argumentos.\nLos argumentos son variables que se le pasan a la función para que ésta las use.\nAl definir la función:\n\nSe definen entre los paréntesis de la función\nToman nombres únicos dentro de la función.\n\n\ndef funcion(argumento1, argumento2):\n    # Cuerpo de la función\n    # argumento1 y argumento2 sólo existen dentro de la función\n\n\nAl invocar la función:\n\nSe pasan los valores que se quieren asignar a los argumentos.\n\nSe evaluan las expresiones\nSe invoca a la función\nSe asigna a cada argumento el valor correspondiente (por orden)\n\n\n\ndef funcion(argumento1, argumento2):\n    # Cuerpo de la función\n    # argumento1 y argumento2 sólo existen dentro de la función\n    # argumento1: valor1\n    # argumento2: valor2\n\nfuncion(valor1, valor2)\n\n\n2.5.1 Ejemplo: Saluda con nombre\nEscribe una función saluda() que reciba un nombre (str) y le salude Hola, {nombre}!\ndef saluda(nombre):\n    print(f\"Hola, {nombre}!\")\n\nsaluda(\"Juan\")\nsaluda(\"María\")\nHola, Juan!\nHola, María!\n\n\n\n2.5.2 Ejemplo: Potencia I\nEscribe una función potencia() que reciba dos números enteros y pinte por pantalla su suma.\ndef potencia(a, b):\n    print(f\"{a} ^ {b} = {a ** b}\")\n\n# A partir de aquí no formaría parte del ejercicio\n# pero necesitamos probar la función\na = 3\nb = 5\npotencia(b, a) # Atención al orden\n\n\n\n2.5.3 Ejemplo: Potencia II\nEscribe un programa que pida al usuario dos números enteros y muestre por pantalla su suma.\ndef potencia(a, b):\n    print(f\"{a} ^ {b} = {a ** b}\")\n\nprint(\"Introduce un número entero:\")\na = int(input())\nprint(\"Introduce un número entero:\")\nb = int(input())\npotencia(a, b)\n\nNota: Cuando aprendamos a devolver valores, podremos modularizar aún más este programa.\n\n\n\n\n\n2.6 Filosofía de diseño modular\n\nComo se ha manifesado de varias formas:\n\nLa clave de la modularización es la encapsulación.\nLas funciones deben ser independientes y reutilizables.\n\nCuando diseñemos una función, debemos tener en cuenta:\n\nSu objetivo específico: una función = una tarea.\nDesacoplamiento: no condiciones el diseño de una función por el resto del programa.\nCuando estás programando una función, el resto del programa “no existe”\n\n\n\n\n2.6.1 Ejemplo de funciones acopladas y desacopladas\nDesarrolla un programa que pida al usuario la temperatura en grados Celsius del motor de su coche y muestre por pantalla la temperatura en grados Fahrenheit.\n\n\nFunción acopladada\ndef convertir_temperatura_motor(temperatura):\n    convertida = (temperatura * 9/5) + 32\n    print(f\"{convertida}°F\")\n\nprint(\"Introduce la temperatura del motor:\")\ntemperatura = float(input())\ncelsius_a_fahrenheit(temperatura)\n\nFunción independiente\ndef celsius_a_fahrenheit(celsius):\n    fahrenheit = (celsius * 9/5) + 32\n    print(f\"{fahrenheit}°F\")\n\nprint(\"Introduce la temperatura del motor:\")\ntemperatura = float(input())\ncelsius_a_fahrenheit(temperatura)"
  },
  {
    "objectID": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.reveal.html#modularización",
    "href": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.reveal.html#modularización",
    "title": "Teoría 401",
    "section": "Modularización",
    "text": "Modularización"
  },
  {
    "objectID": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.reveal.html#funciones",
    "href": "src/01_teoria/04_modularizacion_de_codigo/401_funciones_basicas.reveal.html#funciones",
    "title": "Teoría 401",
    "section": "Funciones",
    "text": "Funciones"
  },
  {
    "objectID": "src/01_teoria/04_modularizacion_de_codigo/403_modulos.reveal.html#chapter",
    "href": "src/01_teoria/04_modularizacion_de_codigo/403_modulos.reveal.html#chapter",
    "title": "Teoría 403",
    "section": "Chapter",
    "text": "Chapter"
  },
  {
    "objectID": "src/01_teoria/05_estructuras_de_datos/502_strings_y_tuplas.reveal.html#chapter",
    "href": "src/01_teoria/05_estructuras_de_datos/502_strings_y_tuplas.reveal.html#chapter",
    "title": "Teoría 502",
    "section": "Chapter",
    "text": "Chapter"
  },
  {
    "objectID": "src/01_teoria/05_estructuras_de_datos/504_estructuras_complejas.reveal.html#chapter",
    "href": "src/01_teoria/05_estructuras_de_datos/504_estructuras_complejas.reveal.html#chapter",
    "title": "Teoría 504",
    "section": "Chapter",
    "text": "Chapter"
  },
  {
    "objectID": "src/01_teoria/07_otros/701_beyond_python.reveal.html#chapter",
    "href": "src/01_teoria/07_otros/701_beyond_python.reveal.html#chapter",
    "title": "Teoría 701",
    "section": "Chapter",
    "text": "Chapter"
  },
  {
    "objectID": "src/02_problemas/201-tipos_numericos.html",
    "href": "src/02_problemas/201-tipos_numericos.html",
    "title": "Problemas 2",
    "section": "",
    "text": "Escribe un programa en Python que solicite al usuario el radio de un círculo y escriba en la pantalla el área y la longitud de la circunferencia correspondientes.\n\\[\nArea = \\pi r^2\n\\]\n\\[\nCircunferencia = 2 \\pi r\n\\]\nIntroduce el radio del círculo:\n1\nEl área del círculo es:\n3.141592653589793\nLa circunferencia del círculo es:\n6.283185307179586\n\n\nSolución\n\nPI = 3.141592653589793\n\nprint(\"Introduce el radio del círculo:\")\nradio = float(input())\n\narea = PI * (radio ** 2)\ncircunferencia = 2 * PI * radio\n\nprint(\"El área del círculo es:\")\nprint(area)\n\nprint(\"La circunferencia del círculo es:\")\nprint(circunferencia)"
  },
  {
    "objectID": "src/02_problemas/201-tipos_numericos.html#área-y-circunferencia",
    "href": "src/02_problemas/201-tipos_numericos.html#área-y-circunferencia",
    "title": "Problemas 2",
    "section": "",
    "text": "Escribe un programa en Python que solicite al usuario el radio de un círculo y escriba en la pantalla el área y la longitud de la circunferencia correspondientes.\n\\[\nArea = \\pi r^2\n\\]\n\\[\nCircunferencia = 2 \\pi r\n\\]\nIntroduce el radio del círculo:\n1\nEl área del círculo es:\n3.141592653589793\nLa circunferencia del círculo es:\n6.283185307179586\n\n\nSolución\n\nPI = 3.141592653589793\n\nprint(\"Introduce el radio del círculo:\")\nradio = float(input())\n\narea = PI * (radio ** 2)\ncircunferencia = 2 * PI * radio\n\nprint(\"El área del círculo es:\")\nprint(area)\n\nprint(\"La circunferencia del círculo es:\")\nprint(circunferencia)"
  },
  {
    "objectID": "src/02_problemas/201-tipos_numericos.html#en-fin-la-hipotenusa",
    "href": "src/02_problemas/201-tipos_numericos.html#en-fin-la-hipotenusa",
    "title": "Problemas 2",
    "section": "2 En fin, la hipotenusa",
    "text": "2 En fin, la hipotenusa\nEscribe un programa Python que solicite al usuario los catetos de un triángulo rectángulo y escriba en la pantalla la longitud de la hipotenusa.\n\\[\nHipotenusa = \\sqrt{cateto1^2 + cateto2^2}\n\\]\nIntroduce la longitud del primer cateto:\n3\nIntroduce la longitud del segundo cateto:\n4\nLa longitud de la hipotenusa es:\n5.0\n\n\nSolución\n\nimport math\n\nprint(\"Introduce la longitud del primer cateto:\")\ncateto1 = float(input())\nprint(\"Introduce la longitud del segundo cateto:\")\ncateto2 = float(input())\n\nhipotenusa = math.sqrt(cateto1 ** 2 + cateto2 ** 2)\n\nprint(\"La longitud de la hipotenusa es:\")\nprint(hipotenusa)"
  },
  {
    "objectID": "src/02_problemas/201-tipos_numericos.html#invertir-un-número-de-2-cifras",
    "href": "src/02_problemas/201-tipos_numericos.html#invertir-un-número-de-2-cifras",
    "title": "Problemas 2",
    "section": "3 Invertir un número de 2 cifras",
    "text": "3 Invertir un número de 2 cifras\nEscribe un programa en Python que solicite al usuario un número de dos cifras y escriba en la pantalla el número invertido.\nIntroduce un número de dos cifras:\n23\nEl número invertido es:\n32\n\n\nSolución\n\nprint(\"Introduce un número de dos cifras:\")\nnumero = int(input())\n\ndecenas = numero // 10\nunidades = numero % 10\ninvertido = unidades * 10 + decenas\n\nprint(\"El número invertido es:\")\nprint(invertido)"
  },
  {
    "objectID": "src/02_problemas/201-tipos_numericos.html#invertir-un-número-de-3-cifras",
    "href": "src/02_problemas/201-tipos_numericos.html#invertir-un-número-de-3-cifras",
    "title": "Problemas 2",
    "section": "4 Invertir un número de 3 cifras",
    "text": "4 Invertir un número de 3 cifras\nEscribe un programa en Python que solicite al usuario un número de tres cifras y escriba en la pantalla el número invertido.\nIntroduce un número de tres cifras:\n123\nEl número invertido es:\n321\n\n\nSolución\n\nprint(\"Introduce un número de tres cifras:\")\nnumero = int(input())\n\ncentenas = numero // 100\ndecenas = (numero % 100) // 10\nunidades = numero % 10\n\ninvertido = unidades * 100 + decenas * 10 + centenas\n\nprint(\"El número invertido es:\")\nprint(invertido)\n\n\n\nSolución alternativa\n\nprint(\"Introduce un número de tres cifras:\")\nnumero = int(input())\n\nnumero_restante = numero\n\nunidades = numero % 10\nnumero_restante = numero // 10\n\ndecenas = numero_restante % 10\nnumero_restante = numero_restante // 10\n\ncentenas = numero_restante % 10\nnumero_restante = numero_restante // 10\n\ninvertido = unidades * 100 + decenas * 10 + centenas\n\nprint(\"El número invertido es:\")\nprint(invertido)"
  },
  {
    "objectID": "src/02_problemas/201-tipos_numericos.html#suma-de-dígitos",
    "href": "src/02_problemas/201-tipos_numericos.html#suma-de-dígitos",
    "title": "Problemas 2",
    "section": "5 Suma de dígitos",
    "text": "5 Suma de dígitos\nEscribe un programa en Python que solicite al usuario un número de tres cifras y escriba en la pantalla la suma de sus dígitos.\nIntroduce un número de tres cifras:\n123\nLa suma de los dígitos es:\n6\n\n\nSolución\n\nprint(\"Introduce un número de tres cifras:\")\nnumero = int(input())\n\ncentenas = numero // 100\ndecenas = (numero % 100) // 10\nunidades = numero % 10\n\nsuma = centenas + decenas + unidades\n\nprint(\"La suma de los dígitos es:\")\nprint(suma)"
  },
  {
    "objectID": "src/02_problemas/201-tipos_numericos.html#promedio-de-3-números",
    "href": "src/02_problemas/201-tipos_numericos.html#promedio-de-3-números",
    "title": "Problemas 2",
    "section": "6 Promedio de 3 números",
    "text": "6 Promedio de 3 números\nEscribe un programa en Python que solicite al usuario tres números enteros y escriba en la pantalla el promedio de los tres.\nIntroduce el primer número:\n1\nIntroduce el segundo número:\n2\nIntroduce el tercer número:\n3\nEl promedio de los tres números es:\n2.0\n\n\nSolución\n\nprint(\"Introduce el primer número:\")\nnumero1 = int(input())\nprint(\"Introduce el segundo número:\")\nnumero2 = int(input())\nprint(\"Introduce el tercer número:\")\nnumero3 = int(input())\n\npromedio = (numero1 + numero2 + numero3) / 3\n\nprint(\"El promedio de los tres números es:\")\nprint(promedio)"
  },
  {
    "objectID": "src/02_problemas/302-composicion_iterativa_while.html",
    "href": "src/02_problemas/302-composicion_iterativa_while.html",
    "title": "Problemas 4",
    "section": "",
    "text": "Escribe la secuencia de números de línea que se ejecutarán en el siguiente bucle while:\n\n1, 2, 3, …\n\ncount = 1\nwhile count &lt;= 3:\n    print(count)\n    count += 1\nprint(\"Fin\")\n\n\nSolución\n\n1, 2, (evalúa como True)\n3, 4, 2, (evalúa como True)\n3, 4, 2 (evalúa como True)\n3, 4, 2 (evalúa como False)\n5\nFíjate que la línea 2 se ejecuta también al final de la última iteración."
  },
  {
    "objectID": "src/02_problemas/302-composicion_iterativa_while.html#seguimiento-de-la-ejecución-de-un-bucle",
    "href": "src/02_problemas/302-composicion_iterativa_while.html#seguimiento-de-la-ejecución-de-un-bucle",
    "title": "Problemas 4",
    "section": "",
    "text": "Escribe la secuencia de números de línea que se ejecutarán en el siguiente bucle while:\n\n1, 2, 3, …\n\ncount = 1\nwhile count &lt;= 3:\n    print(count)\n    count += 1\nprint(\"Fin\")\n\n\nSolución\n\n1, 2, (evalúa como True)\n3, 4, 2, (evalúa como True)\n3, 4, 2 (evalúa como True)\n3, 4, 2 (evalúa como False)\n5\nFíjate que la línea 2 se ejecuta también al final de la última iteración."
  },
  {
    "objectID": "src/02_problemas/302-composicion_iterativa_while.html#está-seguro-de-que-desea-eliminar-el-archivo",
    "href": "src/02_problemas/302-composicion_iterativa_while.html#está-seguro-de-que-desea-eliminar-el-archivo",
    "title": "Problemas 4",
    "section": "2 ¿Está seguro de que desea eliminar el archivo?",
    "text": "2 ¿Está seguro de que desea eliminar el archivo?\nEscribe un programa en Python que solicite al usuario una respuesta y determine si está seguro de eliminar un archivo. El programa debe aceptar las respuestas s, n, si y no. Si la respuesta no es ninguna de las anteriores, el programa repetirá la pregunta hasta que se introduzca una respuesta válida.\n¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\nyeppers\n¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\ns\nARCHIVO ELIMINADO\n¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\nn\nSKIP\n\n\nSolución\n\ncorrecto = False\n\nwhile not correcto:\n    print(\"¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\")\n    respuesta = input()\n\n    if respuesta == \"s\" or respuesta == \"si\":\n        print(\"ARCHIVO ELIMINADO\")\n        correcto = True\n    elif respuesta == \"n\" or respuesta == \"no\":\n        print(\"SKIP\")\n        correcto = True\n\n\n\nSolución alternativa I\n\nprint(\"¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\")\nrespuesta = input()\n\nwhile respuesta != \"s\" and respuesta != \"si\" and respuesta != \"n\" and respuesta != \"no\":\n    print(\"¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\")\n    respuesta = input()\n\nif respuesta == \"s\" or respuesta == \"si\":\n    print(\"ARCHIVO ELIMINADO\")\nelse:\n    print(\"SKIP\")\n\n\n\nSolución alternativa II\n\ncorrecto = False\neliminar = False\n\nwhile not correcto:\n    print(\"¿Está seguro de que desea eliminar el archivo? (s)i/(n)o:\")\n    respuesta = input()\n\n    if respuesta == \"s\" or respuesta == \"si\":\n        correcto = True\n        eliminar = True\n    elif respuesta == \"n\" or respuesta == \"no\":\n        correcto = True\n        eliminar = False\n\nif eliminar:\n    print(\"ARCHIVO ELIMINADO\")\nelse:\n    print(\"SKIP\")"
  },
  {
    "objectID": "src/02_problemas/302-composicion_iterativa_while.html#sumar-una-secuencia",
    "href": "src/02_problemas/302-composicion_iterativa_while.html#sumar-una-secuencia",
    "title": "Problemas 4",
    "section": "3 Sumar una secuencia",
    "text": "3 Sumar una secuencia\nEscribe un programa en Python que solicite iterativamente una secuencia de números enteros. Dicha secuencia terminará cuando el usuario introduzca un número negativo. El programa debe sumar todos los números introducidos y mostrar el resultado.\nIntroduce un número entero:\n1\nIntroduce un número entero:\n2\nIntroduce un número entero:\n3\nIntroduce un número entero:\n-1\nLa suma de los números es: 6\n\n\nSolución\n\nsuma = 0\nnumero = 0\n\nwhile numero &gt;= 0:\n    print(\"Introduce un número entero:\")\n    numero = int(input())\n\n    if numero &gt;= 0:\n        suma = suma + numero\n\nprint(f\"La suma de los números es: {suma}\")\n\n\n\nSolución\n\nsuma = 0\n\nprint(\"Introduce un número entero:\")\nnumero = int(input())\n\nwhile numero &gt;= 0:\n    suma = suma + numero\n\n    print(\"Introduce un número entero:\")\n    numero = int(input())\n\nprint(f\"La suma de los números es: {suma}\")"
  },
  {
    "objectID": "src/02_problemas/302-composicion_iterativa_while.html#sumar-las-cifras-de-un-número",
    "href": "src/02_problemas/302-composicion_iterativa_while.html#sumar-las-cifras-de-un-número",
    "title": "Problemas 4",
    "section": "4 Sumar las cifras de un número",
    "text": "4 Sumar las cifras de un número\nEscribe un programa en Python que solicite al usuario un número entero de n cifras y que sume todas las cifras de dicho número. Pista: puedes inspirarte en la solución alternativa de “Invertir un número de 3 cifras”\nIntroduce un número entero:\n123\nLa suma de las cifras es:\n6\n\n\nSolución\n\nprint(\"Introduce un número entero:\")\nnumero = int(input())\n\nnumero_restante = numero\nsuma = 0\n\nwhile numero_restante &gt; 0:\n    unidades = numero_restante % 10\n    numero_restante = numero_restante // 10\n    suma = suma + unidades\n\nprint(\"La suma de las cifras es:\")\nprint(suma)"
  },
  {
    "objectID": "src/02_problemas/302-composicion_iterativa_while.html#invertir-un-número",
    "href": "src/02_problemas/302-composicion_iterativa_while.html#invertir-un-número",
    "title": "Problemas 4",
    "section": "5 Invertir un número",
    "text": "5 Invertir un número\nEscribe un programa en Python que solicite al usuario un número y escriba en la pantalla el número invertido.\nIntroduce un número:\n12345678\nEl número invertido es:\n87654321\n\n\nSolución\n\nprint(\"Introduce un número:\")\nnumero = int(input())\n\ninvertido = 0\n\nwhile numero &gt; 0:\n    unidades = numero % 10\n    numero = numero // 10\n    invertido = invertido * 10 + unidades\n\nprint(\"El número invertido es:\")\nprint(invertido)"
  },
  {
    "objectID": "src/02_problemas/302-composicion_iterativa_while.html#adivina-el-pin",
    "href": "src/02_problemas/302-composicion_iterativa_while.html#adivina-el-pin",
    "title": "Problemas 4",
    "section": "6 Adivina el PIN",
    "text": "6 Adivina el PIN\nEscribe un programa en Python que simule un sistema de seguridad que solicita al usuario un PIN de 4 dígitos. El PIN correcto es 1234. El usuario tendrá un máximo de 3 intentos para adivinar el PIN.\nIntroduce el PIN:\n1234\n¡PIN correcto!\nIntroduce el PIN:\n4321\nPIN incorrecto. Te quedan 2 intentos.\nIntroduce el PIN:\n1234\n¡PIN correcto!\nIntroduce el PIN:\n0000\nPIN incorrecto. Te quedan 2 intentos.\nIntroduce el PIN:\n0000\nPIN incorrecto. Te quedan 1 intentos.\nIntroduce el PIN:\n0000\nPIN incorrecto. Te quedan 0 intentos.\n¡Bloqueado!\n\n\nSolución\n\nPIN_CORRECTO = 1234\nintentos = 3\nencontrado = False\n\nwhile not encontrado and intentos &gt; 0:\n    print(\"Introduce el PIN:\")\n    pin = int(input())\n\n    if pin == PIN_CORRECTO:\n        encontrado = True\n    else:\n        intentos -= 1\n        print(f\"PIN incorrecto. Te quedan {intentos} intentos.\")\n\nif encontrado:\n    print(\"¡PIN correcto!\")\nelse:\n    print(\"¡Bloqueado!\")"
  },
  {
    "objectID": "src/02_problemas/401-funciones_basicas.html",
    "href": "src/02_problemas/401-funciones_basicas.html",
    "title": "Problemas 6",
    "section": "",
    "text": "Escribe una función repetir(n,c) que imprima n veces el carácter c.\nrepetir(5, '*')  # *****\nrepetir(3, 'x')  # xxx\n*****xxx\n\n\nSolución\n\ndef repetir(n, c):\n    for i in range(0, n):\n        print(c, end=\"\")\n\n\n\n\nEscribe una función pintar_linea(s,n,c) que pinte:\n\ns espacios\nn caracteres c\nUn salto de línea\n\npintar_linea(0, 5, '*')  # *****\npintar_linea(2, 3, 'x')  #   xxx\n*****\n  xxx\n\n\nSolución\n\ndef pintar_linea(s,n, c):\n    repetir(s, ' ')\n    repetir(n, c)\n    print()\n\n\n\n\nEscribe una función pintar_triangulo(n,c) que pinte un triángulo de n filas con el carácter c.\npintar_triangulo(3, 'x')\n  *\n ***\n*****\npintar_triangulo(3, 'x')\n    +\n   +++\n  +++++\n +++++++\n+++++++++\n\n\nSolución\n\ndef pintar_triangulo(n, c):\n    espacios = n - 1\n    chars = 1\n    for _ in range(0, n):\n        pintar_linea(espacios, chars, c)\n        espacios -= 1\n        chars += 2\n\n\n\nSolución (fórmula)\n\ndef pintar_triangulo(n, c):\n    for i in range(0, n):\n        pintar_linea(n - i - 1, 2 * i + 1, c)\n\n\n\n\nEscribe una función pintar_cuadrado(n, m,c) que pinte un cuadrado de nxm con el carácter c.\npintar_cuadrado(3, 3, 'x')\nxxx\nxxx\nxxx\n\npintar_cuadrado(3, 5, '.')\n.....\n.....\n.....\n\n\n\nSolución\n\ndef pintar_cuadrado(n, m, c):\n    for _ in range(0, n):\n        pintar_linea(0, m, c)"
  },
  {
    "objectID": "src/02_problemas/401-funciones_basicas.html#pintar-triángulo",
    "href": "src/02_problemas/401-funciones_basicas.html#pintar-triángulo",
    "title": "Problemas 6",
    "section": "",
    "text": "Escribe una función repetir(n,c) que imprima n veces el carácter c.\nrepetir(5, '*')  # *****\nrepetir(3, 'x')  # xxx\n*****xxx\n\n\nSolución\n\ndef repetir(n, c):\n    for i in range(0, n):\n        print(c, end=\"\")\n\n\n\n\nEscribe una función pintar_linea(s,n,c) que pinte:\n\ns espacios\nn caracteres c\nUn salto de línea\n\npintar_linea(0, 5, '*')  # *****\npintar_linea(2, 3, 'x')  #   xxx\n*****\n  xxx\n\n\nSolución\n\ndef pintar_linea(s,n, c):\n    repetir(s, ' ')\n    repetir(n, c)\n    print()\n\n\n\n\nEscribe una función pintar_triangulo(n,c) que pinte un triángulo de n filas con el carácter c.\npintar_triangulo(3, 'x')\n  *\n ***\n*****\npintar_triangulo(3, 'x')\n    +\n   +++\n  +++++\n +++++++\n+++++++++\n\n\nSolución\n\ndef pintar_triangulo(n, c):\n    espacios = n - 1\n    chars = 1\n    for _ in range(0, n):\n        pintar_linea(espacios, chars, c)\n        espacios -= 1\n        chars += 2\n\n\n\nSolución (fórmula)\n\ndef pintar_triangulo(n, c):\n    for i in range(0, n):\n        pintar_linea(n - i - 1, 2 * i + 1, c)\n\n\n\n\nEscribe una función pintar_cuadrado(n, m,c) que pinte un cuadrado de nxm con el carácter c.\npintar_cuadrado(3, 3, 'x')\nxxx\nxxx\nxxx\n\npintar_cuadrado(3, 5, '.')\n.....\n.....\n.....\n\n\n\nSolución\n\ndef pintar_cuadrado(n, m, c):\n    for _ in range(0, n):\n        pintar_linea(0, m, c)"
  },
  {
    "objectID": "src/02_problemas/401-funciones_basicas.html#funciones-de-apoyo-al-desarrollo",
    "href": "src/02_problemas/401-funciones_basicas.html#funciones-de-apoyo-al-desarrollo",
    "title": "Problemas 6",
    "section": "2 Funciones de apoyo al desarrollo",
    "text": "2 Funciones de apoyo al desarrollo\n\n2.1 Debug\nEscribe una función debug(nombre, valor) que imprima: -- DEBUG nombre: valor. La utilidad de esta función es mostrar el valor de una variable en un punto concreto del programa.\ndebug('x', 5)\ndebug('y', 3)\n– DEBUG x: 5\n– DEBUG y: 3\n\n\nSolución\n\ndef debug(nombre, valor):\n    print(f\"-- DEBUG {nombre}: {valor}\")\n\n\n\n2.2 Check\nEscribe una función check(condicion, error_msg) que imprima --ERROR: error_msg si condicion es False. La utilidad de esta función es asegurar que un valor cumple una condición esperada.\na = 0\ncheck(a != 0, \"El resultado es 0\")\n– ERROR: El resultado es 0\na = 5\ncheck(a &gt; 0, \"Debería ser positivo\")\ncheck(a % 2 == 0, \"Debería ser par\")\n– ERROR: Debería ser par\nfor i in range(0, 5):\n    check(i % 2 == 0, f\"El número {i} debería ser par\")\n– ERROR: El número 1 debería ser par\n– ERROR: El número 3 debería ser par\n\n\nSolución\n\ndef check(condicion, error_msg):\n    if not condicion:\n        print(f\"-- ERROR: {error_msg}\")"
  },
  {
    "objectID": "src/02_problemas/401-funciones_basicas.html#calculadora",
    "href": "src/02_problemas/401-funciones_basicas.html#calculadora",
    "title": "Problemas 6",
    "section": "3 Calculadora",
    "text": "3 Calculadora\n\n3.1 Función resultado\nEscribe una función resultado(a,op,b,r) que imprima: a op b = r.\nresultado(3,'+', 5, 8)\nresultado(2,'*', 2, 4)\n3 + 5 = 8\n2 * 2 = 4\n\n\nSolución\n\ndef resultado(a, op, b, r):\n    print(f\"{a} {op} {b} = {r}\")\n\n\n3.2 Función suma\nEscribe una función suma(a,b) que imprima la suma de a y b.\nsuma(3, 5)\nsuma(2, 2)\n3 + 5 = 8\n2 + 2 = 4\n\n\nSolución\n\ndef suma(a, b):\n    resultado(a, '+', b, a + b)\n\n\n\n3.3 Función producto\nEscribe una función producto(a,b) que imprima el producto de a y b.\nproducto(3, 5)\nproducto(2, 2)\n3 * 5 = 15\n2 * 2 = 4\n\n\nSolución\n\ndef producto(a, b):\n    resultado(a, '*', b, a * b)\n\n\n\n3.4 Calculadora\nEscribe un programa Python que solicite al usuario una operación (suma, producto) y dos números enteros a y b. Si la operación no es válida, el programa mostrará Operación no válida (después de haber solicitado los números igualmente).\nIntroduce una operación (suma, producto):\nsuma\nIntroduce el primer número:\n3\nIntroduce el segundo número:\n5\n3 + 5 = 8\nIntroduce una operación (suma, producto):\nproducto\nIntroduce el primer número:\n3\nIntroduce el segundo número:\n5\n3 * 5 = 15\nIntroduce una operación (suma, producto):\npotencia\nIntroduce el primer número:\n3\nIntroduce el segundo número:\n5\nOperación no válida\n\n\nSolución\n\nprint(\"Introduce una operación (suma, producto):\")\noperacion = input()\nprint(\"Introduce el primer número:\")\na = int(input())\nprint(\"Introduce el segundo número:\")\nb = int(input())\nif operacion == 'suma':\n    suma(a, b)\nelif operacion == 'producto':\n    producto(a, b)\nelse:\n    print(\"Operación no válida\")"
  },
  {
    "objectID": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html",
    "href": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html",
    "title": "Práctica 1",
    "section": "",
    "text": "Desarrolla un programa en Python que solicite al usuario un número real, que representará una longitud medida en centímetros, y escriba en la pantalla la medida equivalente en pulgadas.\nUna pulgada anglosajona actual equivale a 25,4 mm.\nUn ejemplo de ejecución:\nIntroduce un valor en centímetros:\n1\nEn pulgadas son:\n0.39370078740157477\nOtro ejemplo de ejecución:\nIntroduce un valor en centímetros:\n25.4\nEn pulgadas son:\n10.0\nY otro más:\nIntroduce un valor en centímetros:\n84.025\nEn pulgadas son:\n33.080708661417326\nEntrega: Escribe tu programa en un fichero denominado pulgadas.py.\n\n\n\nEscribe un programa en Python que solicite una temperatura expresada en grados Fahrenheit y escriba en la pantalla su equivalente en grados Celsius.\nLa fórmula que proporciona la equivalencia entre grados Celsius y Fahrenheit es\n\\[\nC=\\frac{5}{9}(F - 32)\n\\]\ndonde \\(C\\) es la temperatura en grados Celsius y \\(F\\) es la temperatura en grados Fahrenheit.\nUn ejemplo de ejecución:\nEscriba una temperatura expresada en grados Fahrenheit:\n32\nEn grados Celsius son:\n0.0\nY otro:\nEscriba una temperatura expresada en grados Fahrenheit:\n-459.67\nEn grados Celsius son:\n-273.15000000000003\nAunque probablemente no sea cierto, se dice que Daniel Gabriel Fahrenheit estableció el límite superior de su escala (100 °F) en la temperatura del cuerpo humano. Utiliza tu programa para comprobar que Fahrenheit tenía fiebre cuando calibró su escala.\nEntrega: Escribe tu programa en un fichero denominado fahrenheit.py.\n\n\n\nUna casa de cambio de moneda se ha especializado en dos divisas: euro y yen. Esta casa de cambio utiliza una tasa de conversión de euros a yenes fija durante todo un mes. Para este mes de febrero, ha establecido que va a cambiar un euro por 161,03241 yenes.\nEscribe un programa en Python que pida al usuario que escriba una cantidad no negativa de dinero expresada en euros y le informe de su equivalente en yenes:\nEscriba una cantidad no negativa de dinero en euros:\n43.65\nYenes:\n7029\nComo los yenes no tienen moneda fraccionaria (los senes dejaron de utilizarse en 1953), queremos que el número de yenes resultante se escriba sin decimales.\nUn segundo ejemplo se presenta a continuación para ilustrar el comportamiento deseado del programa:\nEscriba una cantidad no negativa de dinero en euros:\n43.69\nYenes:\n7036\nEntrega: Escribe tu programa en un fichero denominado yenes.py."
  },
  {
    "objectID": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#problemas-de-conversión",
    "href": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#problemas-de-conversión",
    "title": "Práctica 1",
    "section": "",
    "text": "Desarrolla un programa en Python que solicite al usuario un número real, que representará una longitud medida en centímetros, y escriba en la pantalla la medida equivalente en pulgadas.\nUna pulgada anglosajona actual equivale a 25,4 mm.\nUn ejemplo de ejecución:\nIntroduce un valor en centímetros:\n1\nEn pulgadas son:\n0.39370078740157477\nOtro ejemplo de ejecución:\nIntroduce un valor en centímetros:\n25.4\nEn pulgadas son:\n10.0\nY otro más:\nIntroduce un valor en centímetros:\n84.025\nEn pulgadas son:\n33.080708661417326\nEntrega: Escribe tu programa en un fichero denominado pulgadas.py.\n\n\n\nEscribe un programa en Python que solicite una temperatura expresada en grados Fahrenheit y escriba en la pantalla su equivalente en grados Celsius.\nLa fórmula que proporciona la equivalencia entre grados Celsius y Fahrenheit es\n\\[\nC=\\frac{5}{9}(F - 32)\n\\]\ndonde \\(C\\) es la temperatura en grados Celsius y \\(F\\) es la temperatura en grados Fahrenheit.\nUn ejemplo de ejecución:\nEscriba una temperatura expresada en grados Fahrenheit:\n32\nEn grados Celsius son:\n0.0\nY otro:\nEscriba una temperatura expresada en grados Fahrenheit:\n-459.67\nEn grados Celsius son:\n-273.15000000000003\nAunque probablemente no sea cierto, se dice que Daniel Gabriel Fahrenheit estableció el límite superior de su escala (100 °F) en la temperatura del cuerpo humano. Utiliza tu programa para comprobar que Fahrenheit tenía fiebre cuando calibró su escala.\nEntrega: Escribe tu programa en un fichero denominado fahrenheit.py.\n\n\n\nUna casa de cambio de moneda se ha especializado en dos divisas: euro y yen. Esta casa de cambio utiliza una tasa de conversión de euros a yenes fija durante todo un mes. Para este mes de febrero, ha establecido que va a cambiar un euro por 161,03241 yenes.\nEscribe un programa en Python que pida al usuario que escriba una cantidad no negativa de dinero expresada en euros y le informe de su equivalente en yenes:\nEscriba una cantidad no negativa de dinero en euros:\n43.65\nYenes:\n7029\nComo los yenes no tienen moneda fraccionaria (los senes dejaron de utilizarse en 1953), queremos que el número de yenes resultante se escriba sin decimales.\nUn segundo ejemplo se presenta a continuación para ilustrar el comportamiento deseado del programa:\nEscriba una cantidad no negativa de dinero en euros:\n43.69\nYenes:\n7036\nEntrega: Escribe tu programa en un fichero denominado yenes.py."
  },
  {
    "objectID": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#rectángulo",
    "href": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#rectángulo",
    "title": "Práctica 1",
    "section": "2 Rectángulo",
    "text": "2 Rectángulo\nImplementa un programa que:\n\nSolicite al usuario las coordenadas de dos esquinas opuestas de un rectángulo.\n\nx1, y1, x2, y2\n\nUsando esas coordenadas, calcule:\n\nEl área del rectángulo\nEl perímetro del rectángulo\n\n\n\nUn ejemplo de ejecución del programa solicitado:\nIntroduzca x1:\n2\nIntroduzca y1:\n3\nIntroduzca x2:\n5\nIntroduzca y2:\n6\n\nEl área del rectángulo es:\n9.0\n\nEl perímetro del rectángulo es:\n12.0\nY otro:\nIntroduzca x1:\n1.5\nIntroduzca y1:\n7.4\nIntroduzca x2:\n6.8\nIntroduzca y2:\n2.3\n\nEl área del rectángulo es:\n27.03\n\nEl perímetro del rectángulo es:\n20.8\nEntrega: Escribe tu programa en un fichero denominado rectangulo.py."
  },
  {
    "objectID": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#habitación-de-hotel",
    "href": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#habitación-de-hotel",
    "title": "Práctica 1",
    "section": "3 Habitación de hotel",
    "text": "3 Habitación de hotel\nEscribe un programa en Python que interaccione con el usuario mostrando el siguiente comportamiento:\nEscriba un número de habitación:\n514\n\nPlanta:\n5\nNúmero:\n14\nEl número de habitación escrito por el usuario sigue el convenio habitual de numeración de habitaciones en hoteles: el número de centenas indican la planta en la que está la habitación y las decenas y unidades indican el número de habitación dentro de la planta. Por el momento, vamos a suponer que el usuario siempre va a escribir números positivos que representan números de habitación válidas con formato establecido.\nUn segundo ejemplo se presenta a continuación para ilustrar el comportamiento deseado del programa.\nEscriba un número de habitación:\n1803\n\nPlanta:\n18\nNúmero:\n3\nEntrega: Escribe tu programa en un fichero denominado hotel.py."
  },
  {
    "objectID": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#condiciones-booleanas",
    "href": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#condiciones-booleanas",
    "title": "Práctica 1",
    "section": "4 Condiciones booleanas",
    "text": "4 Condiciones booleanas\nEscribe un programa en Python que pida al usuario tres números enteros y diga si se cumple que los tres números son pares, positivos y además el segundo número está comprendido estrictamente entre el primero y el tercero:\nEscribe un primer número:\n2\nEscribe un segundo número:\n4\nEscribe un tercer número:\n8\nCumplen todas las condiciones:\nTrue\nOtro ejemplo de ejecución:\nEscribe un primer número:\n3\nEscribe un segundo número:\n-2\nEscribe un tercer número:\n-5\nCumplen todas las condiciones:\nFalse\nEntrega: Escribe tu programa en un fichero denominado entre_pares.py."
  },
  {
    "objectID": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#entrega-de-la-práctica",
    "href": "src/03_practicas/p1/201_tipos_de_datos_primitivos.html#entrega-de-la-práctica",
    "title": "Práctica 1",
    "section": "5 Entrega de la práctica",
    "text": "5 Entrega de la práctica\nAntes del sábado 15 de febrero a las 18:00, deberán haberse subido a Moodle los siguientes ficheros:\n\npulgadas.py\nfahrenheit.py\nyenes.py\nrectangulo.py\nhotel.py\nentre_pares.py"
  },
  {
    "objectID": "src/03_practicas/p3/302_composicion_iterativa.html",
    "href": "src/03_practicas/p3/302_composicion_iterativa.html",
    "title": "Práctica 3",
    "section": "",
    "text": "Las cajas fuertes de dial (o de combinación) son un tipo de caja fuerte que se abre mediante la introducción de una secuencia de números. La caja fuerte del West Bank se abre introduciendo tres números secretos (8, 23, 42).\n\nSi se acierta un número:\n\nLa caja emitirá un chasquido (tick),\ny se podrá introducir el siguiente número.\n\nSi se falla en alguno:\n\nLa caja se reinicia emitiendo un sonido (clonk),\ny tendrás que volver a empezar con el primer número.\n\nSi se aciertan los tres números seguidos, sin fallos:\n\nLa caja fuerte se abrirá.\nMensaje: &lt;se abre&gt;\n\nEl usuario puede rendirse en cualquier momento introduciendo un 0.\n\n\nBienvenido al West Bank!\n&lt;frente a la caja fuerte&gt;\n8\ntick\n23\ntick\n42\ntick\n&lt;se abre&gt;\nBienvenido al West Bank!\n&lt;frente a la caja fuerte&gt;\n8\ntick\n1\nclonk\n8\ntick\n23\ntick\n42\ntick\n&lt;se abre&gt;\nBienvenido al West Bank!\n&lt;frente a la caja fuerte&gt;\n1\nclonk\n2\nclonk\n0\n&lt;se aleja caminando&gt;\n\n\nDiagrama de estados\n\n\n\nEntrega: Escribe tu programa en un fichero denominado westbank.py."
  },
  {
    "objectID": "src/03_practicas/p3/302_composicion_iterativa.html#la-caja-fuerte-del-west-bank",
    "href": "src/03_practicas/p3/302_composicion_iterativa.html#la-caja-fuerte-del-west-bank",
    "title": "Práctica 3",
    "section": "",
    "text": "Las cajas fuertes de dial (o de combinación) son un tipo de caja fuerte que se abre mediante la introducción de una secuencia de números. La caja fuerte del West Bank se abre introduciendo tres números secretos (8, 23, 42).\n\nSi se acierta un número:\n\nLa caja emitirá un chasquido (tick),\ny se podrá introducir el siguiente número.\n\nSi se falla en alguno:\n\nLa caja se reinicia emitiendo un sonido (clonk),\ny tendrás que volver a empezar con el primer número.\n\nSi se aciertan los tres números seguidos, sin fallos:\n\nLa caja fuerte se abrirá.\nMensaje: &lt;se abre&gt;\n\nEl usuario puede rendirse en cualquier momento introduciendo un 0.\n\n\nBienvenido al West Bank!\n&lt;frente a la caja fuerte&gt;\n8\ntick\n23\ntick\n42\ntick\n&lt;se abre&gt;\nBienvenido al West Bank!\n&lt;frente a la caja fuerte&gt;\n8\ntick\n1\nclonk\n8\ntick\n23\ntick\n42\ntick\n&lt;se abre&gt;\nBienvenido al West Bank!\n&lt;frente a la caja fuerte&gt;\n1\nclonk\n2\nclonk\n0\n&lt;se aleja caminando&gt;\n\n\nDiagrama de estados\n\n\n\nEntrega: Escribe tu programa en un fichero denominado westbank.py."
  },
  {
    "objectID": "src/03_practicas/p3/302_composicion_iterativa.html#serie-de-leibniz",
    "href": "src/03_practicas/p3/302_composicion_iterativa.html#serie-de-leibniz",
    "title": "Práctica 3",
    "section": "2 Serie de Leibniz",
    "text": "2 Serie de Leibniz\nEn matemáticas, la serie de Leibniz es una serie infinita que sirve para calcular el número \\(\\pi\\) de forma aproximada.\n\\[\n\\sum_{n=0}^{\\infty}\\frac{(-1)^{n}}{2n+1}= 1 - \\frac{1}{3} + \\frac{1}{5} -\\frac{1}{7} + \\frac{1}{9} -\\cdots = \\frac{\\pi}{4}\n\\]\nEscribe un programa Python que calcule una aproximación de \\(\\pi\\) mediante la serie de Leibniz. El programa ha de solicitar al usuario un número entero positivo n y calcular la suma de los n primeros términos de la serie de Leibniz. Finalmente, calculará y mostrará: el valor aproximado, el valor real (puedes usar el valor de math.pi) y el error entre ellos.\nNúmero de términos:\n10\nValor aproximado: 3.0418396189294032\nValor real: 3.141592653589793\nError: 0.09975303466038987\nNúmero de términos:\n100\nValor aproximado: 3.1315929035585537\nValor real: 3.141592653589793\nError: 0.00999975003123943\nEntrega: Escribe tu programa en un fichero denominado leibniz.py."
  },
  {
    "objectID": "src/03_practicas/p3/302_composicion_iterativa.html#mano-fuerte-mano-débil",
    "href": "src/03_practicas/p3/302_composicion_iterativa.html#mano-fuerte-mano-débil",
    "title": "Práctica 3",
    "section": "3 Mano fuerte, mano débil",
    "text": "3 Mano fuerte, mano débil\nEn el juego de “Mano fuerte, mano débil” se enfrentan dos jugadores. Cada uno recibe dos cartas de una baraja de poker. El valor de cada carta viene dado por la siguiente tabla:\n\n\n\n2-10\nJ\nQ\nK\nA\n\n\n\n\n2-10\n11\n12\n13\n14\n\n\n\nUna mano gana a otra si ambas cartas son superiores a las del rival (no importa la posición de la carta)\n\n14, 3 gana a 2, 13 (porque 14&gt;13 y 3&gt;2)\n14, 3 gana a 13, 2 (porque 14&gt;13 y 3&gt;2)\n14, 2 empata con 3, 3 (porque 14&gt;3 y 2&lt;3)\n8, 4 pierde con 14, 8 (porque 8&gt;4 y 14&gt;8)\n8, 4 empata con 8, 8 (porque 4&lt;8 y 8=8)\nEsto genera varias reglas implícitas:\n\nSacar un 14 (as) garantiza victoria o empate. (Ninguna mano puede ganarte porque, como mínimo, empatas).\nSacar un 2 (carta más baja) garantiza cero victorias. (Cualquier mano te gana o empata).\n\n\nLa siguiente tabla ilustra todas las combinaciones posibles para la mano 8, 10.\n\n\n\n\n2\n3\n4\n5\n6\n7\n8\n9\nT\nJ\nQ\nK\nA\n\n\n\n\n2\no\no\no\no\no\no\no\no\n\n\n\n\n\n\n\n3\no\no\no\no\no\no\no\no\n\n\n\n\n\n\n\n4\no\no\no\no\no\no\no\no\n\n\n\n\n\n\n\n5\no\no\no\no\no\no\no\no\n\n\n\n\n\n\n\n6\no\no\no\no\no\no\no\no\n\n\n\n\n\n\n\n7\no\no\no\no\no\no\no\no\n\n\n\n\n\n\n\n8\no\no\no\no\no\no\n\n\n\n\n\n\n\n\n\n9\no\no\no\no\no\no\n\n\n\nx\nx\nx\nx\n\n\nT\n\n\n\n\n\n\n\n\n\nx\nx\nx\nx\n\n\nJ\n\n\n\n\n\n\n\nx\nx\nx\nx\nx\nx\n\n\nQ\n\n\n\n\n\n\n\nx\nx\nx\nx\nx\nx\n\n\nK\n\n\n\n\n\n\n\nx\nx\nx\nx\nx\nx\n\n\nA\n\n\n\n\n\n\n\nx\nx\nx\nx\nx\nx\n\n\n\nEscribe un programa Python que, dada una mano de un jugador (introducidas como los dos puntos de cada carta), calcule cuantas combinaciones ganan, cuantas empatan y cuantas pierden. NO has de tener en cuenta las probabilidades de que salga una carta, sólo contar cuantas combinaciones ganan, empatan o pierden.\nIntroduce la primera carta:\n14\nIntroduce la segunda carta:\n14\nVictorias: 144\nEmpates: 25\nDerrotas: 0\nIntroduce la primera carta:\n8\nIntroduce la segunda carta:\n10\nVictorias: 60\nEmpates: 77\nDerrotas: 32\nEntrega: Escribe tu programa en un fichero denominado manofuerte.py."
  },
  {
    "objectID": "src/03_practicas/p3/302_composicion_iterativa.html#mano-fuerte-mano-débil-ii",
    "href": "src/03_practicas/p3/302_composicion_iterativa.html#mano-fuerte-mano-débil-ii",
    "title": "Práctica 3",
    "section": "4 Mano fuerte, mano débil (II)",
    "text": "4 Mano fuerte, mano débil (II)\nPartiendo del ejercicio anterior (crea una copia del ejercicio una vez lo hayas acabado), extiende el funcionamiento del mismo añadiendo la representación de la tabla de casos. En dicha tabla:\n\no indica que tu mano gana.\nx indica que tu mano pierde.\n. indica que tu mano empata.\n\nTip: Recuerda lo aprendido en el ejercicio Dibujar tablas de multiplicar\nIntroduce la primera carta:\n8\nIntroduce la segunda carta:\n10\n\n   |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 |\n 2 |  o |  o |  o |  o |  o |  o |  o |  o |  . |  . |  . |  . |  . |\n 3 |  o |  o |  o |  o |  o |  o |  o |  o |  . |  . |  . |  . |  . |\n 4 |  o |  o |  o |  o |  o |  o |  o |  o |  . |  . |  . |  . |  . |\n 5 |  o |  o |  o |  o |  o |  o |  o |  o |  . |  . |  . |  . |  . |\n 6 |  o |  o |  o |  o |  o |  o |  o |  o |  . |  . |  . |  . |  . |\n 7 |  o |  o |  o |  o |  o |  o |  o |  o |  . |  . |  . |  . |  . |\n 8 |  o |  o |  o |  o |  o |  o |  . |  . |  . |  . |  . |  . |  . |\n 9 |  o |  o |  o |  o |  o |  o |  . |  . |  . |  x |  x |  x |  x |\n10 |  . |  . |  . |  . |  . |  . |  . |  . |  . |  x |  x |  x |  x |\n11 |  . |  . |  . |  . |  . |  . |  . |  x |  x |  x |  x |  x |  x |\n12 |  . |  . |  . |  . |  . |  . |  . |  x |  x |  x |  x |  x |  x |\n13 |  . |  . |  . |  . |  . |  . |  . |  x |  x |  x |  x |  x |  x |\n14 |  . |  . |  . |  . |  . |  . |  . |  x |  x |  x |  x |  x |  x |\n\nVictorias: 60\nEmpates:   77\nDerrotas:  32\n\nEntrega: Escribe tu programa en un fichero denominado manofuerte2.py."
  },
  {
    "objectID": "src/03_practicas/p3/302_composicion_iterativa.html#entrega-de-la-práctica",
    "href": "src/03_practicas/p3/302_composicion_iterativa.html#entrega-de-la-práctica",
    "title": "Práctica 3",
    "section": "5 Entrega de la práctica",
    "text": "5 Entrega de la práctica\nAntes del 15 de marzo a las 18:00, deberán haberse subido a Moodle los siguientes ficheros:\n\nwestbank.py\nleibniz.py\nmanofuerte.py\nmanofuerte2.py"
  },
  {
    "objectID": "src/02_problemas/401-funciones_basicas.html#dibujo",
    "href": "src/02_problemas/401-funciones_basicas.html#dibujo",
    "title": "Problemas 6",
    "section": "",
    "text": "Escribe una función repetir(n,c) que imprima n veces el carácter c.\nrepetir(5, '*')  # *****\nrepetir(3, 'x')  # xxx\n*****xxx\n\n\nSolución\n\ndef repetir(n, c):\n    for i in range(0, n):\n        print(c, end=\"\")\n\n\n\n\nEscribe una función pintar_linea(s,n,c) que pinte:\n\ns espacios\nn caracteres c\nUn salto de línea\n\npintar_linea(0, 5, '*')  # *****\npintar_linea(2, 3, 'x')  #   xxx\n*****\n  xxx\n\n\nSolución\n\ndef pintar_linea(s,n, c):\n    repetir(s, ' ')\n    repetir(n, c)\n    print()\n\n\n\n\nEscribe una función pintar_triangulo(n,c) que pinte un triángulo de n filas con el carácter c.\npintar_triangulo(3, 'x')\n  *\n ***\n*****\npintar_triangulo(3, 'x')\n    +\n   +++\n  +++++\n +++++++\n+++++++++\n\n\nSolución\n\ndef pintar_triangulo(n, c):\n    espacios = n - 1\n    chars = 1\n    for _ in range(0, n):\n        pintar_linea(espacios, chars, c)\n        espacios -= 1\n        chars += 2\n\n\n\nSolución (fórmula)\n\ndef pintar_triangulo(n, c):\n    for i in range(0, n):\n        pintar_linea(n - i - 1, 2 * i + 1, c)\n\n\n\n\nEscribe una función pintar_cuadrado(n, m,c) que pinte un cuadrado de nxm con el carácter c.\npintar_cuadrado(3, 3, 'x')\nxxx\nxxx\nxxx\n\npintar_cuadrado(3, 5, '.')\n.....\n.....\n.....\n\n\n\nSolución\n\ndef pintar_cuadrado(n, m, c):\n    for _ in range(0, n):\n        pintar_linea(0, m, c)"
  }
]